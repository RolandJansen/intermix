{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/main.js","src/core.js","src/events.js","src/SoundWave.js","src/Sound.js","src/Sequencer.js","src/Part.js","src/scheduleWorker.js","node_modules/webworkify/index.js"],"names":["intermix","require","events","SoundWave","Sound","Sequencer","Part","module","exports","audioCtx","window","AudioContext","webkitAudioContext","Error","evProp","evType","note","control","evClass","audio","synth","fx","midi","osc","validateClass","eClass","hasOwnProperty","validateType","eType","validatePropInstrument","instr","validatePropToneVelo","value","isNaN","Number","isInteger","validatePropDuration","validateProps","eProps","type","key","indexOf","convertTone","tone","notes","str","toLowerCase","match","substring","length","oct","slice","createEvent","class","props","createAudioNote","velocity","duration","instrument","property","core","audioSrc","this","ac","buffer","metaData","self","ArrayBuffer","decodeAudioData","Array","concatBinariesToAudioBuffer","loadFile","response","binBuffers","loadFiles","prototype","rawAudioSrc","then","decoded","binaryBuffers","audioBuffer","forEach","binBuffer","tmpAudioBuffer","push","addWaveMetaData","appendAudioBuffer","buffer1","buffer2","numberOfChannels","Math","min","tmp","createBuffer","sampleRate","i","channel","getChannelData","set","existingBuffer","newBuffer","start","end","filename","onloadCallback","async","asynchronously","request","XMLHttpRequest","addEventListener","updateProgress","transferComplete","transferFailed","transferCanceled","open","responseType","onload","send","filenames","names","split","name","sortBinBuffers","map","el","soundWave","wave","queue","loop","gainNode","pannerNode","soundLength","isPaused","startOffset","startOffsets","startTime","loopStart","loopEnd","playbackRate","detune","setupAudioChain","createGain","createStereoPanner","connect","destination","gain","createBufferSource","bufferSource","onended","destroyBufferSource","bsNode","disconnect","node","index","splice","playLooped","delay","resume","currentTime","bs","tmpPlaybackRate","stop","pause","processSeqEvent","seqEvent","setLoopStart","setLoopEnd","releaseLoop","resetLoop","setPlaybackRate","getPlaybackRate","setTone","semiTone","getTone","setDetune","getDetune","getUID","random","toString","substr","work","worker","bpm","resolution","interval","lookahead","runqueue","timePerStep","nextStepTime","nextStep","lastPlayedStep","isRunning","animationFrame","setTimePerStep","scheduleWorker","onmessage","e","data","scheduler","postMessage","limit","addPartsToRunqueue","fireEvents","setQueuePointer","part","pointer","deletePartsFromRunqueue","indices","id","markForDelete","unshift","seqEvents","pattern","position","runQueue","requestAnimationFrame","draw","bind","lookAheadDelta","stepsAhead","round","updateFrame","console","log","addPart","removePart","setBpm","getLastPlayedStep","copyArray","sourceArray","destArray","multiply","initPattern","addEvent","pos","removeEvent","getLength","getNotePositions","positions","extendOnTop","extLength","extension","concat","extendOnEnd","timer","setInterval","clearInterval","bundleFn","arguments","sources","cache","stringify","JSON","fn","wkey","cacheKeys","Object","keys","l","exp","floor","pow","wcache","Function","skey","scache","src","join","URL","webkitURL","mozURL","msURL","Worker","createObjectURL","Blob"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\n//intermix = require('./core.js');\nvar intermix = require('./core.js') || {};\nintermix.events = require('./events.js');\nintermix.SoundWave = require('./SoundWave.js');\nintermix.Sound = require('./Sound.js');\nintermix.Sequencer = require('./Sequencer.js');\nintermix.Part = require('./Part.js');\n\nmodule.exports = intermix;\n","/**\n * This is the foundation of the Intermix library.\n * It simply creates the audio context objects\n * and exports it so it can be easily consumed\n * from all classes of the library.\n *\n * @return {AudioContext} The AudioContext object\n *\n * @todo Should we do backwards-compatibility for older api-versions?\n * @todo Check for mobile/iOS compatibility.\n * @todo Check if we're running on node\n *\n * @example <caption>Suspend and resume the audio context to\n * create a pause button. This should be used with createAudioWorker\n * as an error will be thrown when suspend is called on an offline audio context.\n * You can also pause single sounds with <i>Sound.pause()</i>.\n * Please read <a href=\"https://developer.mozilla.org/de/docs/Web/API/AudioContext/suspend\">the developer docs at MDN</a>\n * to get a better idea of this.</caption>\n * susresBtn.onclick = function() {\n *   if(Intermix.state === 'running') {\n *     Intermix.suspend().then(function() {\n *       susresBtn.textContent = 'Resume context';\n *     });\n *   } else if (Intermix.state === 'suspended') {\n *     Intermix.resume().then(function() {\n *       susresBtn.textContent = 'Suspend context';\n *     });\n *   }\n * }\n */\n'use strict';\n\nvar audioCtx = null;\n\n(function() {\n\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n  if (window.AudioContext) {\n    audioCtx = new window.AudioContext();\n  } else {\n    throw new Error('Couldn\\'t initialize the audio context.');\n  }\n\n})();\n\nmodule.exports = audioCtx;\n","'use strict';\n\n/**\n * This is not about javascript events! It's just\n * a definition of the events that the sequencer can handle plus\n * some functions to create valid events.\n * The class defines which subsystem is invoked to process the event.\n * Every class can have several types and a type consists of one or\n * more properties.\n * @example <caption>Create a note event for an audio object</caption>\n * var note = intermix.events.createAudioNote('c3', 65, 128, aSoundObject);\n */\n\n/**\n * All valid event properties in one handy array.\n * @type {Array}\n */\nvar evProp = [\n  'instrument', // the event receiver\n  'tone',       // Int between 0 and 127 beginning at c0\n  'duration',   // Int representing a number of 64th notes\n  'velocity',   // Int between 0 and 127\n  'pitch',\n  'volume',\n  'pan'\n];\n\n/**\n * All valid event types and the properties assotiated with them.\n * Type are valid with one, several or all of its properties.\n * @type {Object}\n */\nvar evType = {\n  'note': [ evProp[0], evProp[1], evProp[2], evProp[3] ],\n  'control': [ evProp[4], evProp[5], evProp[6] ]\n};\n\n/**\n * All valid event classes and the types assotiated with them.\n * @type {Object}\n */\nvar evClass = {\n  'audio': [evType.note, evType.control],\n  'synth': [evType.note, evType.control],\n  'fx': [],\n  'midi': [],\n  'osc': []\n};\n\n/**\n * Validates the class of a sequencer event\n * @private\n * @param  {String}   eClass Event class\n * @return {boolean}  true if class exists, false if not\n */\nvar validateClass = function(eClass) {\n  if (evClass.hasOwnProperty(eClass)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Validates the type of a sequencer event\n * @private\n * @param  {String}   eType Event type\n * @return {boolean}  true if type exists, false if not\n */\nvar validateType = function(eType) {\n  if (evType.hasOwnProperty(eType)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Checks if an instrument is an object.\n * This is a poorly weak test but that's\n * all we can do here.\n * @param  {Object} instr An instrument object\n * @return {boolean}      true if it's an object, false if not\n */\nvar validatePropInstrument = function(instr) {\n  if (typeof instr === 'object') {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Validates if a tone or velocity value is\n * an integer between 0 and 127.\n * @private\n * @param  {Int}  value   The number that represents a tone\n * @return {boolean}      True if its a valid tone, false if not\n */\nvar validatePropToneVelo = function(value) {\n  if (!isNaN(value) && Number.isInteger(value) && value >= 0 && value <= 127) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Validates if a duration is a positive integer.\n * @private\n * @param  {Int}  value   Number representing multiple 64th notes\n * @return {boolean}      True if its a valid duration, false if not\n */\nvar validatePropDuration = function(value) {\n  if (!isNaN(value) && Number.isInteger(value) && value >= 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Validates an object of event properties.\n * It checks the properties are valid for the given type.\n * @private\n * @param  {Object} eProps  Object with event properties\n * @param  {String} eType   Event type to validate against\n * @return {boolean}        true if all props are valid, false if not\n */\nvar validateProps = function(eProps, eType) {\n  var type = evType[eType];\n  for (var key in eProps)  {\n    if (evProp.indexOf(key) === -1 &&\n    type.indexOf(key) === -1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Takes a string of the form c3 or d#4 and\n * returns the corresponding number.\n * @param  {String} tone String representing a note\n * @return {Int}         Number representing a note\n */\nvar convertTone = function(tone) {\n  var notes = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];\n  var str = tone.toLowerCase();\n\n  if (str.match(/^[a-h]#?[0-9]$/)) {\n    var note = str.substring(0, str.length - 1);\n    var oct = str.slice(-1);\n\n    if (note === 'h') {\n      note = 'b';\n    }\n    return notes.indexOf(note) + oct * 12;\n  } else {\n    throw new Error('Unvalid string. Has to be like [a-h]<#>[0-9]');\n  }\n};\n\n/**\n * Creates a sequencer event.\n * @private\n * @param  {String} eClass Event class\n * @param  {String} eType  Event type\n * @param  {Object} eProps Object with event properties\n * @return {Object}        Sequencer event\n */\nvar createEvent = function(eClass, eType, eProps) {\n  if (validateClass(eClass) &&\n    validateType(eType) &&\n    validateProps(eProps, eType)) {\n    return {\n      'class': eClass,\n      'type': eType,\n      'props': eProps\n    };\n  } else {\n    throw new Error('Unable to create sequencer event. Wrong parameters');\n  }\n};\n\n/**\n * Creates an audio note event\n * @param  {Int|String} tone     Tone between 0 and 127 or string (c3, d#4)\n * @param  {Int}        velocity Velocity between 0 and 127\n * @param  {Int}        duration Duration in 64th notes\n * @return {Object}              All properties in one object\n */\nvar createAudioNote = function(tone, velocity, duration, instr) {\n  var props = {};\n  if (typeof tone === 'string') {\n    tone = convertTone(tone);\n  }\n  if (tone && validatePropToneVelo(tone)) {\n    props.tone = tone;\n  }\n  if (velocity && validatePropToneVelo(velocity)) {\n    props.velocity = velocity;\n  }\n  if (duration && validatePropDuration(duration)) {\n    props.duration = duration;\n  }\n  if (instr && validatePropInstrument(instr)) {\n    props.instrument = instr;\n  } else {\n    throw new Error('A sequencer event must have an instrument as property');\n  }\n  return createEvent('audio', 'note', props);\n};\n\nmodule.exports = {\n  class: evClass,\n  type: evType,\n  property: evProp,\n  createAudioNote: createAudioNote\n};\n","'use strict';\n\nvar core = require('./core.js');\n\n/**\n * <p>\n * Creates a wrapper in which an audio buffer lives.\n * A SoundWave object just holds audio data and does nothing else.\n * If you want to play the sound, you have to additionally create a\n * <a href=\"Sound.html\">Sound</a> object.\n * It can handle one or more ArrayBuffers or filenames\n * (*.wav, *.mp3) as data sources.\n * </p><p>\n * Multiple sources will be concatenated into one audio buffer.\n * This is not the same as creating multiple SoundWave objects.\n * It's like a wavetable: All start/end positions will be saved so\n * you can trigger the original samples without using multiple buffers.\n * Possible usages are multisampled sounds, loops or wavesequences (kind of).\n * </p>\n *\n * @example <caption>Play a sound from an audio file:</caption>\n * var soundWave = new intermix.SoundWave('file.wav');\n * var sound = new intermix.Sound(soundWave);\n * sound.play;\n * @example <caption>Concatenate multiple source files into one buffer<br>\n * in the given order and play them (This is broken in v0.1. Don't use it!):</caption>\n * var soundWave = new intermix.SoundWave('file1.wav,file2.wav,file3.wav');\n * var sound = new intermix.Sound(soundWave);\n * sound.play;\n * @example <caption>\n * Using ArrayBuffers instead of filenames will come in handy if you want<br>\n * to have full control over XHR or use a preloader (here: preload.js):\n * </caption>\n * var queue = new createjs.LoadQueue();\n * queue.on('complete', handleComplete);\n * queue.loadManifest([\n *     {id: 'src1', src:'file1.wav', type:createjs.AbstractLoader.BINARY},\n *     {id: 'src2', src:'file2.wav', type:createjs.AbstractLoader.BINARY}\n * ]);\n *\n * function handleComplete() {\n *     var binData1 = queue.getResult('src1');\n *     var binData2 = queue.getResult('src2');\n *     var wave1 = new intermix.SoundWave(binData1);\n *     var wave2 = new intermix.SoundWave(binData2);\n *     var concatWave = new intermix.SoundWave([binData1, binData2]);\n * };\n * @constructor\n * @param  {(Object|Object[]|string)} audioSrc   One or more ArrayBuffers or filenames\n */\nvar SoundWave = function(audioSrc) {\n\n  this.ac = core;       //currently just used for tests\n  this.buffer = null;   //AudioBuffer\n  this.metaData = [];   //start-/endpoints and length of single waves\n  var self = this;\n\n  if (audioSrc) {\n    if (audioSrc instanceof ArrayBuffer) {\n      //one audio buffer to decode\n      this.decodeAudioData(audioSrc);\n    } else if (audioSrc instanceof Array && audioSrc[0] instanceof ArrayBuffer) {\n      //multiple audio buffers to decode and concatenate\n      this.concatBinariesToAudioBuffer(audioSrc);\n    } else if (typeof audioSrc === 'string' && audioSrc.indexOf(',') === -1) {\n      //one file to load/decode\n      this.loadFile(audioSrc, function(response) {\n        self.buffer = self.decodeAudioData(response);\n      });\n    } else if (typeof audioSrc === 'string' && audioSrc.indexOf(',') > -1) {\n      //multiple files to load/decode and cancatinate\n      var binBuffers = this.loadFiles(audioSrc);\n      this.buffer = this.concatBinariesToAudioBuffer(binBuffers, this.buffer);\n    } else {\n      throw new Error('Cannot create SoundWave object: Unsupported data format');\n    }\n  } else {\n    //start the object with empty buffer. Usefull for testing and advanced usage.\n  }\n\n};\n\n/**\n * Takes binary audio data, turns it into an audio buffer object and\n * stores it in this.buffer.\n * Basically a wrapper for the web-audio-api decodeAudioData function.\n * It uses the new promise syntax so it probably won't work in all browsers by now.\n * @private\n * @param  {ArrayBuffer}  rawAudioSrc Audio data in raw binary format\n * @return {Promise}                  Promise that indicates if operation was successfull.\n */\nSoundWave.prototype.decodeAudioData = function(rawAudioSrc) {\n  var self = this;\n  return core.decodeAudioData(rawAudioSrc).then(function(decoded) {\n    self.buffer = decoded;\n  });\n};\n\n/**\n * Concatenates one or more ArrayBuffers to an AudioBuffer.\n * @private\n * @param  {Array} binaryBuffers  Array holding one or more ArrayBuffers\n * @param  {AudioBuffer} audioBuffer   An existing AudioBuffer object\n * @return {AudioBuffer}               The concatenated AudioBuffer\n */\nSoundWave.prototype.concatBinariesToAudioBuffer = function(binaryBuffers, audioBuffer) {\n  binaryBuffers.forEach(function(binBuffer) {\n    var tmpAudioBuffer = this.decodeAudioData(binBuffer);\n    this.metaData.push(this.addWaveMetaData(audioBuffer, tmpAudioBuffer));\n    audioBuffer = this.appendAudioBuffer(audioBuffer, tmpAudioBuffer);\n  }, this);\n\n  return audioBuffer;\n};\n\n/**\n * Appends two audio buffers. Suggested by Chris Wilson:<br>\n * http://stackoverflow.com/questions/14143652/web-audio-api-append-concatenate-different-audiobuffers-and-play-them-as-one-son\n * @private\n * @param  {AudioBuffer} buffer1 The first audio buffer\n * @param  {AudioBuffer} buffer2 The second audio buffer\n * @return {AudioBuffer}         buffer1 + buffer2\n */\nSoundWave.prototype.appendAudioBuffer = function(buffer1, buffer2) {\n  var numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);\n  var tmp = core.createBuffer(numberOfChannels,\n    (buffer1.length + buffer2.length),\n    buffer1.sampleRate);\n  for (var i = 0; i < numberOfChannels; i++) {\n    var channel = tmp.getChannelData(i);\n    channel.set( buffer1.getChannelData(i), 0);\n    channel.set( buffer2.getChannelData(i), buffer1.length);\n  }\n  return tmp;\n};\n\n/**\n * Creates a dictionary with start/stop points and length in sample-frames\n * of an appended waveform and adds it to the metaData array.\n * @private\n * @param  {AudioBuffer} existingBuffer The 'old' buffer that gets appended\n * @param  {AudioBuffer} newBuffer      The buffer that gets appended\n * @return {Object}                     Dictionary with start/stop/length data\n */\nSoundWave.prototype.addWaveMetaData = function(existingBuffer, newBuffer) {\n  return {\n    start: existingBuffer.length + 1,\n    end: existingBuffer.length + newBuffer.length,\n    length: newBuffer.length\n  };\n};\n\n/**\n * Loads a binary file and calls a function with the\n * returned ArrayBuffer as its argument when done.\n * @todo    Test in synchronous mode or remove it completely\n * @param  {string}   filename       The file to be loaded\n * @param  {function} onloadCallback The function to be called\n * @param  {boolean}  [async=true]   Asynchronous loading\n * @example\n * var arrayBuffer;\n * this.loadFile('file1.wav', function(response) {\n *   arrayBuffer = response;\n * });\n */\nSoundWave.prototype.loadFile = function(filename, onloadCallback, async) {\n  var self = this;\n  var asynchronously = true;\n  var request = new window.XMLHttpRequest();\n\n  request.addEventListener('progress', self.updateProgress);\n  request.addEventListener('load', self.transferComplete);\n  request.addEventListener('error', self.transferFailed);\n  request.addEventListener('abort', self.transferCanceled);\n\n  if (async) {\n    asynchronously = async;\n  }\n\n  request.open('GET', filename, asynchronously);\n  request.responseType = 'arraybuffer';\n\n  request.onload = function() {\n    onloadCallback(request.response);\n  };\n\n  request.send();\n};\n\nSoundWave.prototype.updateProgress = function() {};\n\nSoundWave.prototype.transferComplete = function() {\n\n};\n\nSoundWave.prototype.transferFailed = function() {};\n\nSoundWave.prototype.transferCanceled = function() {};\n\n/**\n * Loads multiple binary files and returns an array\n * with the data from the files in the given order.\n * @param  {Array}  filenames List with filenames\n * @return {Array}            Array of ArrayBuffers\n */\nSoundWave.prototype.loadFiles = function(filenames) {\n  var self = this;\n  var binBuffers = [];\n  var names = filenames.split(',');\n  names.forEach(function(name) {\n    self.loadFile(name, function(response) {\n      binBuffers[name] = response;\n    });\n  });\n\n  return this.sortBinBuffers(names, binBuffers);\n};\n\n/**\n * Sort ArrayBuffers the same order, like the filename\n * parameters.\n * @private\n * @param  {Array}  filenames  Array with filenames\n * @param  {Array}  binBuffers Array with ArrayBuffer\n * @return {Array}             Array with sorted ArrayBuffers\n */\nSoundWave.prototype.sortBinBuffers = function(filenames, binBuffers) {\n  return filenames.map(function(el) {\n    return binBuffers[el];\n  });\n};\n\nmodule.exports = SoundWave;\n","'use strict';\n\nvar core = require('./core.js');\n\n/**\n * <p>\n * Play a sound that can be looped. Pause/Start works sample-accurate\n * at any rate. Hit the start button multiple times to have multiple\n * sounds played. All parameters are adjustable in realtime.\n * </p>\n *\n * @example\n * var soundWave = new intermix.SoundWave('audiofile.wav');\n * var sound = new intermix.Sound(soundWave);\n * sound.start();\n * @tutorial Sound\n * @constructor\n * @param  {Object} soundWave SoundWave object including the buffer with audio data to be played\n */\nvar Sound = function(soundWave) {\n\n  this.wave = null;\n  this.ac = core;           //currently just used for tests\n  this.queue = [];          //all currently active streams\n  this.loop = false;\n  this.gainNode = null;\n  this.pannerNode = null;\n\n  this.soundLength = 0;\n  this.isPaused = false;\n  this.startOffset = 0;\n  this.startOffsets = [];   //holds start offsets if paused\n  this.startTime = 0;       //when the sound starts to play\n  this.loopStart = 0;\n  this.loopEnd = null;\n  this.playbackRate = 1;\n  this.detune = 0;\n\n  if (soundWave) {\n    this.wave = soundWave;\n    this.buffer = soundWave.buffer;\n    this.soundLength = this.loopEnd = this.buffer.duration;\n    this.setupAudioChain();\n  } else {\n    throw new Error('Error initialising Sound object: parameter missing.');\n  }\n};\n\n/**\n * Creates a gain and stereo-panner node, connects them\n * (gain -> panner) and sets gain to 1 (max value).\n * @private\n * @return {Void}\n */\nSound.prototype.setupAudioChain = function() {\n  this.gainNode = core.createGain();\n  this.pannerNode = core.createStereoPanner();\n  this.gainNode.connect(this.pannerNode);\n  this.pannerNode.connect(core.destination);\n  this.gainNode.gain.value = 1;\n};\n\n/**\n * Creates and configures a BufferSourceNode\n * that can be played once and then destroys itself.\n * @private\n * @return {BufferSourceNode} The BufferSourceNode\n */\nSound.prototype.createBufferSource = function() {\n  var self = this;\n  var bufferSource = core.createBufferSource();\n  bufferSource.buffer = this.buffer;\n  bufferSource.connect(this.gainNode);\n  bufferSource.onended = function() {\n    //console.log('onended fired');\n    self.destroyBufferSource(bufferSource);\n  };\n  return bufferSource;\n};\n\n/**\n * Destroyes a given AudioBufferSourceNode and deletes it\n * from the sourceNode queue. This is used in the onended\n * callback of all BufferSourceNodes to avoid dead references.\n * @private\n * @param  {bsNode} bsNode the bufferSource to be destroyed.\n */\nSound.prototype.destroyBufferSource = function(bsNode) {\n  bsNode.disconnect();\n  this.queue.forEach(function(node, index) {\n    if (node === bsNode) {\n      this.queue.splice(index, 1);\n    }\n  }, this);\n};\n\n/**\n * Starts a sound (AudioBufferSourceNode) and stores a references\n * in a queue. This enables you to play multiple sounds at once\n * and even stop them all at a given time.\n * @param  {Boolean} playLooped Whether the sound should be looped or not\n * @param  {float}   delay      Time in seconds the sound pauses before the stream starts\n * @param  {float}   duration   Time preriod after the stream should end\n * @return {Void}\n */\nSound.prototype.start = function(playLooped, delay, duration) {\n  if (this.isPaused && this.queue.length > 0) {\n    this.resume();\n  } else {\n    var startTime = 0;\n\n    if (delay) {\n      startTime = delay;\n    } else {\n      startTime = core.currentTime;\n    }\n    var bs = this.createBufferSource();\n\n    if (playLooped) {\n      bs.loop = playLooped;\n      bs.loopStart = this.loopStart;\n      bs.loopEnd = this.loopEnd;\n    }\n    bs.playbackRate.value = bs.tmpPlaybackRate = this.playbackRate;\n    bs.detune.value = this.detune;\n    bs.startTime = startTime;   // extend node with a starttime property\n\n    this.queue.push(bs);\n    if (duration) {\n      bs.start(startTime, this.startOffset, duration);\n    } else {\n      bs.start(startTime, this.startOffset);\n    }\n\n    this.startOffset = 0;\n  }\n};\n\n/**\n * Stops all audio stream, even the ones that are just scheduled.\n * It also cleans the queue so that the sound object is ready for another round.\n * @return {Void}\n */\nSound.prototype.stop = function() {\n  this.queue.forEach(function(node) {\n    node.stop();\n    node.disconnect();\n  });\n  this.queue = [];  //release all references\n};\n\n/**\n * Stops all audio streams of this sound temporarily.\n * This currently just works in Chrome 49+ only.\n * If you want a global, accurate pause function\n * use suspend/resume from the core module.\n * @return  {Void}\n */\nSound.prototype.pause = function() {\n  if (!this.isPaused) {\n    this.queue.forEach(function(node) {\n      node.tmpPlaybackRate = node.playbackRate.value;\n      node.playbackRate.value = 0.0;\n    });\n    this.isPaused = true;\n  }\n};\n\n/**\n * Resumes all streams if they were paused.\n * @return {Void}\n */\nSound.prototype.resume = function() {\n  this.queue.forEach(function(node) {\n    node.playbackRate.value = node.tmpPlaybackRate;\n    delete node.tmpPlaybackRate;\n  });\n  this.isPaused = false;\n};\n\n/**\n * Processes an event fired by the sequencer.\n * @param  {Object} seqEvent A sequencer event\n * @return {Void}\n */\nSound.prototype.processSeqEvent = function(seqEvent) {\n  //this.setTone(seqEvent.props.tone);\n  if (seqEvent.props.duration) {\n    this.start(false,\n      seqEvent.props.delay,\n      seqEvent.props.duration);\n  } else {\n    this.start(false,\n      seqEvent.props.delay);\n  }\n};\n\n/**\n * Sets the startpoint of the loop\n * @param  {float} value  loop start in seconds\n * @return {Void}\n */\nSound.prototype.setLoopStart = function(value) {\n  this.loopStart = value;\n  this.queue.forEach(function(node) {\n    node.loopStart = value;\n  });\n};\n\n/**\n * Sets the endpoint of the loop\n * @param  {float} value  loop end in seconds\n * @return {Void}\n */\nSound.prototype.setLoopEnd = function(value) {\n  this.loopEnd = value;\n  this.queue.forEach(function(node) {\n    node.loopEnd = value;\n  });\n};\n\n/**\n * Releases the loop of all running nodes,\n * Nodes will run until end and stop.\n * @return {Void}\n */\nSound.prototype.releaseLoop = function() {\n  this.queue.forEach(function(node) {\n    node.loop = false;\n  });\n};\n\n/**\n * Resets the start and endpoint to start end endpoint of the AudioBuffer\n * @return {Void}\n */\nSound.prototype.resetLoop = function() {\n  this.loopStart = 0;\n  this.loopEnd = this.soundLength;\n};\n\n/**\n * Set the playback rate of the sound in percentage\n * (1 = 100%, 2 = 200%)\n * @param  {float}  value   Rate in percentage\n * @return {Void}\n */\nSound.prototype.setPlaybackRate = function(value) {\n  this.playbackRate = value;\n  this.queue.forEach(function(node) {\n    node.playbackRate.value = value;\n  });\n};\n\n/**\n * Get the current playback rate\n * @return {float}  The playback rate in percentage (1.25 = 125%)\n */\nSound.prototype.getPlaybackRate = function() {\n  return this.playbackRate;\n};\n\n/**\n * Set the tone within two octave (+/-12 tones)\n * @param  {Integer}  semi tone\n * @return {Void}\n */\nSound.prototype.setTone = function(semiTone) {\n  if (semiTone >= -12 && semiTone <= 12) {\n    this.detune = semiTone * 100;\n  } else {\n    throw new Error('Semi tone is ' + semiTone + '. Must be between +/-12.');\n  }\n};\n\n/**\n * Get the last played semitone. This doesn't has to be an\n * integer between -/+12 as the sound can be detuned with\n * more precision.\n * @return {float}  Semitone between -/+12\n */\nSound.prototype.getTone = function() {\n  return this.detune / 100;\n};\n\n/**\n * Detune the sound oscillation in cents (+/- 1200)\n * @param  {Integer}  value  detune in cents\n * @return {Void}\n */\nSound.prototype.setDetune = function(value) {\n  if (value >= -1200 && value <= 1200) {\n    this.detune = value;\n  } else {\n    throw new Error('Detune parameter is ' + value + '. Must be between +/-1200.');\n  }\n};\n\n/**\n * get the current detune in cents (+/- 1200)\n * @return {Integer}  Detune in cents\n */\nSound.prototype.getDetune = function() {\n  return this.detune;\n};\n\n/**\n * This is not in use and can probably be removed\n * @return {Int} Random number\n */\nSound.prototype.getUID = function() {\n  return Math.random().toString().substr(2, 8);\n};\n\nmodule.exports = Sound;\n","'use strict';\n\nvar work = require('webworkify');   //prepares the worker for browserify\nvar core = require('./core.js');\nvar worker = require('./scheduleWorker.js');\n\n/**\n * The main class of the sequencer. It does the queuing of\n * parts and events and runs the schedulers that fire events\n * and draws to the screen.\n * @example\n * var part = new intermix.Part();\n * var seq = new intermix.Sequencer();\n * part.addEvent(someNote, 0);\n * seq.addPart(part, 0);\n * seq.start();\n * @constructor\n */\nvar Sequencer = function() {\n\n  var self = this;\n  this.ac = core;             //currently just used for tests\n  this.bpm = 120;             //beats per minute\n  this.resolution = 64;       //shortest possible note. You normally don't want to touch this.\n  this.interval = 100;        //the interval in miliseconds the scheduler gets invoked.\n  this.lookahead = 0.3;       //time in seconds the scheduler looks ahead.\n                              //should be longer than interval.\n  this.queue = [];            //List with all parts of the score\n  this.runqueue = [];         //list with parts that are playing or will be played shortly\n\n  this.timePerStep;           //period of time between two steps\n  this.nextStepTime = 0;      //time in seconds when the next step will be triggered\n  this.nextStep = 0;          //position in the queue that will get triggered next\n  this.lastPlayedStep = 0;    //step in queue that was played (not triggered) recently (used for drawing).\n  this.loop = false;          //play a section of the queue in a loop\n  this.loopStart;             //first step of the loop\n  this.loopEnd;               //last step of the loop\n  this.isRunning = false;     //true if sequencer is running, otherwise false\n  this.animationFrame;        //has to be overridden with a function. Will be called in the\n                              //draw function with the lastPlayedStep int as parameter.\n\n  // set time per setTimePerStep\n  this.timePerStep = this.setTimePerStep(this.bpm, this.resolution);\n\n  // Initialize the scheduler-timer\n  this.scheduleWorker = work(worker);\n\n  /*eslint-enable */\n\n  this.scheduleWorker.onmessage = function(e) {\n    if (e.data === 'tick') {\n      self.scheduler();\n    }\n  };\n\n  this.scheduleWorker.postMessage({'interval': this.interval});\n};\n\n/**\n * Reads events from the master queue and fires them.\n * It gets called at a constant rate, looks ahead in\n * the queue and fires all events in the near future\n * with a delay computed from the current bpm value.\n * @private\n * @return {Void}\n */\nSequencer.prototype.scheduler = function() {\n  var limit = core.currentTime + this.lookahead;\n  // if invoked for the first time or previously stopped\n  if (this.nextStepTime === 0) {\n    this.nextStepTime = core.currentTime;\n  }\n\n  while (this.nextStepTime < limit) {\n    this.addPartsToRunqueue();\n    this.fireEvents();\n    this.nextStepTime += this.timePerStep;\n\n    this.setQueuePointer();\n  }\n};\n\n/**\n * Looks in the master queue for parts and adds\n * copies of them to the runqueue.\n * @private\n * @return {Void}\n */\nSequencer.prototype.addPartsToRunqueue = function() {\n  if (this.queue[this.nextStep]) {\n    if (this.queue[this.nextStep].length === 1) {\n      var part = this.queue[this.nextStep][0];\n      part.pointer = 0;\n      this.runqueue.push(part);\n    } else {\n      this.queue[this.nextStep].forEach(function(part) {\n        part.pointer = 0;\n        this.runqueue.push(part);\n      }, this);\n    }\n  }\n};\n\n/**\n * Deletes parts from runqueue. It is important, that the indices\n * of the parts are sorted from max to min. Otherwise the forEach\n * loop won't work.\n * @private\n * @param  {Array} indices  Indices of the parts in the runqueue\n * @return {Void}\n */\nSequencer.prototype.deletePartsFromRunqueue = function(indices) {\n  if (indices.length > 0) {\n    indices.forEach(function(id) {\n      delete this.runqueue[id].pointer;\n      this.runqueue.splice(id, 1);\n    }, this);\n  }\n};\n\n/**\n * Fires all events for the upcomming step.\n * @private\n * @return {Void}\n */\nSequencer.prototype.fireEvents = function() {\n  var markForDelete = [];\n  this.runqueue.forEach(function(part, index) {\n    if (part.pointer === part.length - 1) {\n      markForDelete.unshift(index);\n    } else {\n      var seqEvents = part.pattern[part.pointer];\n      if (seqEvents && seqEvents.length > 1) {\n        seqEvents.forEach(function(seqEvent) {\n          this.processSeqEvent(seqEvent, this.nextStepTime);\n        }, this);\n      } else if (seqEvents && seqEvents.length === 1) {\n        this.processSeqEvent(seqEvents[0], this.nextStepTime);\n      }\n    }\n    part.pointer++;\n  }, this);\n  this.deletePartsFromRunqueue(markForDelete);\n};\n\n/**\n * Invokes the appropriate subsystem to process the event\n * @private\n * @param  {Object} seqEvent  The event to process\n * @param  {float}  delay     time in seconds when the event should start\n * @return {Void}\n */\nSequencer.prototype.processSeqEvent = function(seqEvent, delay) {\n  if (delay) {\n    seqEvent.props['delay'] = delay;\n  }\n  seqEvent.props.instrument.processSeqEvent(seqEvent);\n};\n\n/**\n * Sets the pointer to the next step that should be played\n * in the master queue. If we're playing in loop mode,\n * jump back to loopstart when end of loop is reached.\n * @private\n * @param   {Int}   position  New position in the master queue\n * @return  {Void}\n */\nSequencer.prototype.setQueuePointer = function(position) {\n  if (this.loop) {\n    if (this.nextStep >= this.loopEnd) {\n      this.nextStep = this.loopStart;\n      this.runQueue = [];\n    } else {\n      this.nextStep++;\n    }\n  } else if (position) {\n    this.nextStep = position;\n  } else {\n    this.nextStep++;\n  }\n  // console.log('next step: ' + this.nextStep);\n};\n\n/**\n * Starts the sequencer\n * @return {Void}\n */\nSequencer.prototype.start = function() {\n  if (!this.isRunning) {\n    this.scheduleWorker.postMessage('start');\n    this.isRunning = true;\n    window.requestAnimationFrame(this.draw.bind(this));\n  }\n};\n\n/**\n * Stops the sequencer (halts at the current position)\n * @return {Void}\n */\nSequencer.prototype.stop = function() {\n  this.scheduleWorker.postMessage('stop');\n  //this.runQueue = [];\n  this.nextStepTime = 0;\n  this.isRunning = false;\n};\n\n/**\n * Scheduler that runs a drawing function every time\n * the screen refreshes. The function Sequencer.animationFrame()\n * has to be overridden by the application with stuff to be drawn on the screen.\n * It calls itself recursively on every frame as long as the sequencer is running.\n * @private\n * @return {Void}\n */\nSequencer.prototype.draw = function() {\n  // first we'll have to find out, what step was played recently.\n  // this is somehow clumsy because the sequencer doesn't keep track of that.\n  var lookAheadDelta = this.nextStepTime - core.currentTime;\n  if (lookAheadDelta >= 0) {\n    var stepsAhead = Math.round(lookAheadDelta / this.timePerStep);\n\n    if (this.nextStep < stepsAhead) {\n      // we just jumped to the start of a loop\n      this.lastPlayedStep = this.loopEnd + this.nextStep - stepsAhead;\n    } else {\n      this.lastPlayedStep = this.nextStep - stepsAhead;\n    }\n\n    this.updateFrame(this.lastPlayedStep);\n  }\n\n  if (this.isRunning) {\n    window.requestAnimationFrame(this.draw.bind(this));\n  }\n};\n\n/**\n * Runs between screen refresh. Has to be overridden by the\n * app to render to the screen.\n * @param  {Int}  lastPlayedStep  The 64th step that was played recently\n * @return {Void}\n */\nSequencer.prototype.updateFrame = function(lastPlayedStep) {\n  console.log(lastPlayedStep);\n};\n\n/**\n * Adds a part to the master queue.\n * @param  {Object} part      An instance of Part\n * @param  {Int}    position  Position in the master queue\n * @return {Void}\n */\nSequencer.prototype.addPart = function(part, position) {\n  if (part.length && part.pattern) {\n    if (!this.queue[position]) {\n      this.queue[position] = [];\n    }\n    this.queue[position].push(part);\n  } else {\n    throw new Error('Given parameter doesn\\'t seem to be a part object');\n  }\n};\n\n/**\n * Removes a part object from the master queue\n * @param  {Object} part     Part instance to be removed\n * @param  {Int}    position Position in the master queue\n * @return {Void}\n */\nSequencer.prototype.removePart = function(part, position) {\n  if (this.queue[position] instanceof Array &&\n    this.queue[position].length > 0) {\n    var index = this.queue[position].indexOf(part);\n    this.queue[position].splice(index, 1);\n  } else {\n    throw new Error('Part not found at position ' + position + '.');\n  }\n};\n\n/**\n * Set beats per minute\n * @param  {Int}   bpm beats per minute\n * @return {Void}\n */\nSequencer.prototype.setBpm = function(bpm) {\n  this.bpm = bpm;\n  this.timePerStep = this.setTimePerStep(bpm, this.resolution);\n};\n\n/**\n * Computes the time in seconds as float value\n * between one shortest posssible note\n * (64th by default) and the next.\n * @private\n * @param  {float}  bpm        beats per minute\n * @param  {Int}    resolution shortest possible note value\n * @return {float}             time in seconds\n */\nSequencer.prototype.setTimePerStep = function(bpm, resolution) {\n  return (60 * 4) / (bpm * resolution);\n};\n\nSequencer.prototype.getLastPlayedStep = function() {\n\n};\n\n/**\n * Makes a copy of a flat array.\n * Uses a pre-allocated while-loop\n * which seems to be the fasted way\n * (by far) of doing this:\n * http://jsperf.com/new-array-vs-splice-vs-slice/113\n * @private\n * @param  {Array} sourceArray Array that should be copied.\n * @return {Array}             Copy of the source array.\n */\nSequencer.prototype.copyArray = function(sourceArray) {\n  var destArray = new Array(sourceArray.length);\n  var i = sourceArray.length;\n  while (i--) {\n    destArray[i] = sourceArray[i];\n  }\n  return destArray;\n};\n\nmodule.exports = Sequencer;\n","'use strict';\n\n/**\n * Represents a part of a sequence. It can be\n * used in many ways:\n * <ul>\n * <li>A part of a track like in piano-roll sequencers</li>\n * <li>A pattern like in step sequencers, drum computers and trackers</li>\n * <li>A loop like in live sequencers</li>\n * </ul>\n * Technically it can store any type of event your system is capable of.\n * This means it is not limited to audio, midi, osc or dmx but can hold\n * any type of javascript object. A possible usecase would be to trigger\n * screen events with the draw function of the sequencer object.\n * @example\n * var sound = new intermix.Sound(soundWaveObject);\n * var seq = new intermix.Sequencer();\n * var part = new intermix.Part();\n * var note = intermix.events.createAudioNote('a3', 1, 0, sound);\n * part.addEvent(note, 0);\n * part.addEvent(note, 4);\n * seq.addPart(part, 0);\n * @constructor\n * @param  {float}  length       Length of the part in 64th notes (default: 64)\n */\nvar Part = function(length) {\n\n  this.resolution = 16; // (resolution * multiply) should alwasy be 64\n  this.multiply = 4;    // resolution multiplier\n  this.length = 64;     // length of the pattern in 64th notes\n  this.name = 'Part';   // name of this part\n  this.pattern = [];    // the actual pattern with notes etc.\n\n  if (length) {\n    this.length = length;\n  }\n\n  this.pattern = this.initPattern(this.length);\n};\n\n/**\n * Initialize an empty pattern for the part.\n * @private\n * @param  {float}  length  Length of the pattern mesured in bars (4 beats = 1 bar)\n * @return {Object} The current context to make the function chainable.\n */\nPart.prototype.initPattern = function(length) {\n  var pattern = [];\n  for (var i = 0; i < (length); i++) {\n    pattern[i] = [];\n  }\n  return pattern;\n};\n\n/**\n * Adds an event to the pattern at a given position\n * @param  {Object} seqEvent  The event (note, controller, whatever)\n * @param  {Int}    position  Position in the pattern\n * @return {Object} The current context to make the function chainable.\n */\nPart.prototype.addEvent = function(seqEvent, position) {\n  if (position <= this.resolution) {\n    var pos = (position) * this.multiply;\n    this.pattern[pos].push(seqEvent);\n  } else {\n    throw new Error('Position out of pattern bounds.');\n  }\n  return this;\n};\n\n/**\n * Removes an event at a given position\n * @param  {Object} seqEvent  The event (note, controller, whatever)\n * @param  {Int}    position  Position in the pattern\n * @return {Void}\n */\nPart.prototype.removeEvent = function(seqEvent, position) {\n  var pos = (position) * this.multiply;\n  var index = this.pattern[pos].indexOf(seqEvent);\n  this.pattern[pos].splice(index, 1);\n};\n\n/**\n * Get the length of the pattern in 64th notes\n * @return {Int}    Length of the pattern\n */\nPart.prototype.getLength = function() {\n  return this.pattern.length;\n};\n\n/**\n * Get all positions that contain at least one event.\n * Can be handy to draw events on the screen.\n * @example <caption>from {@tutorial Stepsequencer}</caption>\n * bdSteps = bdPart.getNotePositions();\n * bdSteps.forEach(function(pos) {\n *   document.getElementById('bd' + pos).style.backgroundColor = 'red';\n * });\n * @return {Array}  List with all non-empty pattern entries\n */\nPart.prototype.getNotePositions = function() {\n  var positions = [];\n  this.pattern.forEach(function(el, index) {\n    if (el.length > 0) {\n      positions.push(index / this.multiply);\n    }\n  }, this);\n  return positions;\n};\n\n/**\n * Extends a part at the top/start.\n * @param  {float}  extLength Length in 64th notes\n * @return {Void}\n */\nPart.prototype.extendOnTop = function(extLength) {\n  var extension = this.initPattern(extLength);\n  this.pattern = extension.concat(this.pattern);\n};\n\n/**\n * Extends a part at the end\n * @param  {float}  extLength Length in 64th notes\n * @return {Void}\n */\nPart.prototype.extendOnEnd = function(extLength) {\n  var extension = this.initPattern(extLength);\n  this.pattern = this.pattern.concat(extension);\n};\n\nmodule.exports = Part;\n","/**\n * This is a webworker that provides a timer\n * that fires the scheduler for the sequencer.\n * This is because timing here is  more stable\n * than in the main thread.\n * The syntax is adapted to the commonjs module pattern.\n * @example <caption>It is just for library internal\n * usage. See Sequencer.js for details.</caption>\n * worker.postMessage({ 'interval': 200 });\n * worker.postMessage('start');\n * worker.postMessage('stop');\n * worker.terminate();  //webworker internal function, just for completeness\n */\n'use strict';\n\nvar timer = null;\nvar interval = 100;\n\nvar worker = function(self) {\n  self.addEventListener('message', function(e) {\n    if (e.data === 'start') {\n      timer = setInterval(function() {self.postMessage('tick');}, interval);\n    } else if (e.data === 'stop') {\n      clearInterval(timer);\n    } else if (e.data.interval) {\n      interval = e.data.interval;\n      if (timer) {\n        clearInterval(timer);\n        timer = setInterval(function() {self.postMessage('tick');}, interval);\n      }\n    }\n  });\n};\n\nmodule.exports = worker;\n","var bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn) {\n    var keys = [];\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'], (\n            // try to call default if defined to also support babel esmodule\n            // exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);'\n        )),\n        scache\n    ];\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(sources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    return new Worker(URL.createObjectURL(\n        new Blob([src], { type: 'text/javascript' })\n    ));\n};\n"]}