{"version":3,"sources":["d:/Users/jansen/git/intermix.js/node_modules/browser-pack/_prelude.js","src/main.js","d:/Users/jansen/git/intermix.js/src/core.js","d:/Users/jansen/git/intermix.js/src/events.js","d:/Users/jansen/git/intermix.js/src/SoundWave.js","d:/Users/jansen/git/intermix.js/src/Sound.js","d:/Users/jansen/git/intermix.js/src/Part.js","d:/Users/jansen/git/intermix.js/src/Sequencer.js","d:/Users/jansen/git/intermix.js/src/scheduleWorker.js","d:/Users/jansen/git/intermix.js/node_modules/webworkify/index.js"],"names":["intermix","require","events","SoundWave","Sound","Sequencer","Part","module","exports","audioCtx","isMobile","Android","window","navigator","userAgent","match","iOS","BlackBerry","Opera","Windows","any","AudioContext","webkitAudioContext","Error","evProp","evType","note","control","evClass","audio","synth","fx","midi","osc","validateClass","eClass","hasOwnProperty","validateType","eType","validatePropInstrument","instr","validatePropToneVelo","value","isNaN","Number","isInteger","validatePropDuration","validateProps","eProps","type","key","indexOf","convertTone","tone","notes","str","toLowerCase","substring","length","oct","slice","createEvent","class","props","createAudioNote","velocity","duration","instrument","property","core","audioSrc","self","this","ac","buffer","createBuffer","sampleRate","metaData","loadFile","then","response","decodeAudioData","decoded","err","Array","loadMultipleFiles","ArrayBuffer","decodeAudioSources","audioBuffers","joinAudioBuffers","audioBuffer","prototype","urls","filenames","stripFilenames","loadFiles","binBuffers","promises","push","storeMetaData","Promise","all","bufferAndMeta","buffers","forEach","rawAudioSrc","joinedBuffer","resolve","reject","AudioBuffer","appendAudioBuffer","TypeError","buffer1","buffer2","numberOfChannels","Math","min","newBuffer","i","channel","getChannelData","set","names","fnames","start","index","getMetaData","map","url","split","pop","name","bufLength","end","fetch","ok","arrayBuffer","getBufferFragment","chnCount","frameCount","chn","newChannel","oldChannel","sortBinBuffers","el","soundWave","wave","queue","loop","gainNode","pannerNode","soundLength","isPaused","startOffset","startOffsets","startTime","loopStart","loopEnd","playbackRate","detune","setupAudioChain","createGain","createStereoPanner","connect","destination","gain","createBufferSource","bufferSource","onended","destroyBufferSource","bsNode","disconnect","node","splice","playLooped","delay","resume","currentTime","bs","tmpPlaybackRate","stop","pause","processSeqEvent","seqEvent","setLoopStart","setLoopEnd","releaseLoop","resetLoop","setPlaybackRate","getPlaybackRate","setTone","semiTone","getTone","setDetune","getDetune","getUID","random","toString","substr","resolution","multiply","pattern","initPattern","addEvent","position","pos","removeEvent","getLength","getNotePositions","positions","extendOnTop","extLength","extension","concat","extendOnEnd","work","worker","bpm","interval","lookahead","runqueue","timePerStep","nextStepTime","nextStep","lastPlayedStep","isRunning","animationFrame","setTimePerStep","scheduleWorker","onmessage","e","data","scheduler","postMessage","limit","addPartsToRunqueue","fireEvents","setQueuePointer","part","pointer","deletePartsFromRunqueue","indices","id","markForDelete","unshift","seqEvents","resetQueuePointer","requestAnimationFrame","draw","bind","state","suspend","lookAheadDelta","stepsAhead","round","updateFrame","console","log","addPart","removePart","setBpm","getLastPlayedStep","copyArray","sourceArray","destArray","timer","addEventListener","setInterval","clearInterval","bundleFn","arguments","sources","cache","stringify","JSON","fn","wkey","cacheKeys","Object","keys","l","exp","floor","pow","wcache","Function","skey","scache","src","join","URL","webkitURL","mozURL","msURL","Worker","createObjectURL","Blob"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\n//intermix = require('./core.js');\r\nvar intermix = require('./core.js') || {};\r\nintermix.events = require('./events.js');\r\nintermix.SoundWave = require('./SoundWave.js');\r\nintermix.Sound = require('./Sound.js');\r\nintermix.Sequencer = require('./Sequencer.js');\r\nintermix.Part = require('./Part.js');\r\n\r\nmodule.exports = intermix;\r\n","/**\r\n * This is the foundation of the Intermix library.\r\n * It simply creates the audio context objects\r\n * and exports it so it can be easily consumed\r\n * from all classes of the library.\r\n *\r\n * @return {AudioContext} The AudioContext object\r\n *\r\n * @todo Should we do backwards-compatibility for older api-versions?\r\n * @todo Check for mobile/iOS compatibility.\r\n * @todo Check if we're running on node\r\n *\r\n * @example <caption>Suspend and resume the audio context to\r\n * create a pause button. This should be used with createAudioWorker\r\n * as an error will be thrown when suspend is called on an offline audio context.\r\n * You can also pause single sounds with <i>Sound.pause()</i>.\r\n * Please read <a href=\"https://developer.mozilla.org/de/docs/Web/API/AudioContext/suspend\">the developer docs at MDN</a>\r\n * to get a better idea of this.</caption>\r\n * susresBtn.onclick = function() {\r\n *   if(Intermix.state === 'running') {\r\n *     Intermix.suspend().then(function() {\r\n *       susresBtn.textContent = 'Resume context';\r\n *     });\r\n *   } else if (Intermix.state === 'suspended') {\r\n *     Intermix.resume().then(function() {\r\n *       susresBtn.textContent = 'Suspend context';\r\n *     });\r\n *   }\r\n * }\r\n */\r\n'use strict';\r\n\r\nvar audioCtx = null;\r\n\r\nvar isMobile = {\r\n  'Android': function() {\r\n    return window.navigator.userAgent.match(/Android/i);\r\n  },\r\n  'iOS': function() {\r\n    return window.navigator.userAgent.match(/iPhone|iPad|iPod/i);\r\n  },\r\n  'BlackBerry': function() {\r\n    return window.navigator.userAgent.match(/BlackBerry/i);\r\n  },\r\n  'Opera': function() {\r\n    return window.navigator.userAgent.match(/Opera Mini/i);\r\n  },\r\n  Windows: function() {\r\n    return window.navigator.userAgent.match(/IEMobile/i) ||\r\n    window.navigator.userAgent.match(/WPDesktop/i);\r\n  },\r\n  any: function() {\r\n    return (isMobile.Android() ||\r\n    isMobile.iOS() ||\r\n    isMobile.BlackBerry() ||\r\n    isMobile.Opera() ||\r\n    isMobile.Windows());\r\n  }\r\n};\r\n\r\n(function() {\r\n\r\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\n  if (typeof window.AudioContext !== 'undefined') {\r\n    audioCtx = new window.AudioContext();\r\n  } else {\r\n    throw new Error('Couldn\\'t initialize the audio context.');\r\n  }\r\n\r\n})();\r\n\r\nmodule.exports = audioCtx;\r\n","'use strict';\r\n\r\n/**\r\n * This is not about javascript events! It's just\r\n * a definition of the events that the sequencer can handle plus\r\n * some functions to create valid events.\r\n * The class defines which subsystem is invoked to process the event.\r\n * Every class can have several types and a type consists of one or\r\n * more properties.\r\n * @example <caption>Create a note event for an audio object</caption>\r\n * var note = intermix.events.createAudioNote('c3', 65, 128, aSoundObject);\r\n */\r\n\r\n/**\r\n * All valid event properties in one handy array.\r\n * @type {Array}\r\n */\r\nvar evProp = [\r\n  'instrument', // the event receiver\r\n  'tone',       // Int between 0 and 127 beginning at c0\r\n  'duration',   // Int representing a number of 64th notes\r\n  'velocity',   // Int between 0 and 127\r\n  'pitch',\r\n  'volume',\r\n  'pan'\r\n];\r\n\r\n/**\r\n * All valid event types and the properties assotiated with them.\r\n * Type are valid with one, several or all of its properties.\r\n * @type {Object}\r\n */\r\nvar evType = {\r\n  'note': [ evProp[0], evProp[1], evProp[2], evProp[3] ],\r\n  'control': [ evProp[4], evProp[5], evProp[6] ]\r\n};\r\n\r\n/**\r\n * All valid event classes and the types assotiated with them.\r\n * @type {Object}\r\n */\r\nvar evClass = {\r\n  'audio': [evType.note, evType.control],\r\n  'synth': [evType.note, evType.control],\r\n  'fx': [],\r\n  'midi': [],\r\n  'osc': []\r\n};\r\n\r\n/**\r\n * Validates the class of a sequencer event\r\n * @private\r\n * @param  {String}   eClass Event class\r\n * @return {boolean}  true if class exists, false if not\r\n */\r\nvar validateClass = function(eClass) {\r\n  if (evClass.hasOwnProperty(eClass)) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Validates the type of a sequencer event\r\n * @private\r\n * @param  {String}   eType Event type\r\n * @return {boolean}  true if type exists, false if not\r\n */\r\nvar validateType = function(eType) {\r\n  if (evType.hasOwnProperty(eType)) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Checks if an instrument is an object.\r\n * This is a poorly weak test but that's\r\n * all we can do here.\r\n * @param  {Object} instr An instrument object\r\n * @return {boolean}      true if it's an object, false if not\r\n */\r\nvar validatePropInstrument = function(instr) {\r\n  if (typeof instr === 'object') {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Validates if a tone or velocity value is\r\n * an integer between 0 and 127.\r\n * @private\r\n * @param  {Int}  value   The number that represents a tone\r\n * @return {boolean}      True if its a valid tone, false if not\r\n */\r\nvar validatePropToneVelo = function(value) {\r\n  if (!isNaN(value) && Number.isInteger(value) && value >= 0 && value <= 127) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Validates if a duration is a positive integer.\r\n * @private\r\n * @param  {Int}  value   Number representing multiple 64th notes\r\n * @return {boolean}      True if its a valid duration, false if not\r\n */\r\nvar validatePropDuration = function(value) {\r\n  if (!isNaN(value) && Number.isInteger(value) && value >= 0) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Validates an object of event properties.\r\n * It checks the properties are valid for the given type.\r\n * @private\r\n * @param  {Object} eProps  Object with event properties\r\n * @param  {String} eType   Event type to validate against\r\n * @return {boolean}        true if all props are valid, false if not\r\n */\r\nvar validateProps = function(eProps, eType) {\r\n  var type = evType[eType];\r\n  for (var key in eProps)  {\r\n    if (evProp.indexOf(key) === -1 &&\r\n    type.indexOf(key) === -1) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Takes a string of the form c3 or d#4 and\r\n * returns the corresponding number.\r\n * @param  {String} tone String representing a note\r\n * @return {Int}         Number representing a note\r\n */\r\nvar convertTone = function(tone) {\r\n  var notes = ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];\r\n  var str = tone.toLowerCase();\r\n\r\n  if (str.match(/^[a-h]#?[0-9]$/)) {\r\n    var note = str.substring(0, str.length - 1);\r\n    var oct = str.slice(-1);\r\n\r\n    if (note === 'h') {\r\n      note = 'b';\r\n    }\r\n    return notes.indexOf(note) + oct * 12;\r\n  } else {\r\n    throw new Error('Unvalid string. Has to be like [a-h]<#>[0-9]');\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a sequencer event.\r\n * @private\r\n * @param  {String} eClass Event class\r\n * @param  {String} eType  Event type\r\n * @param  {Object} eProps Object with event properties\r\n * @return {Object}        Sequencer event\r\n */\r\nvar createEvent = function(eClass, eType, eProps) {\r\n  if (validateClass(eClass) &&\r\n    validateType(eType) &&\r\n    validateProps(eProps, eType)) {\r\n    return {\r\n      'class': eClass,\r\n      'type': eType,\r\n      'props': eProps\r\n    };\r\n  } else {\r\n    throw new Error('Unable to create sequencer event. Wrong parameters');\r\n  }\r\n};\r\n\r\n/**\r\n * Creates an audio note event\r\n * @param  {Int|String} tone     Tone between 0 and 127 or string (c3, d#4)\r\n * @param  {Int}        velocity Velocity between 0 and 127\r\n * @param  {Int}        duration Duration in 64th notes\r\n * @return {Object}              All properties in one object\r\n */\r\nvar createAudioNote = function(tone, velocity, duration, instr) {\r\n  var props = {};\r\n  if (typeof tone === 'string') {\r\n    tone = convertTone(tone);\r\n  }\r\n  if (tone && validatePropToneVelo(tone)) {\r\n    props.tone = tone;\r\n  }\r\n  if (velocity && validatePropToneVelo(velocity)) {\r\n    props.velocity = velocity;\r\n  }\r\n  if (duration && validatePropDuration(duration)) {\r\n    props.duration = duration;\r\n  }\r\n  if (instr && validatePropInstrument(instr)) {\r\n    props.instrument = instr;\r\n  } else {\r\n    throw new Error('A sequencer event must have an instrument as property');\r\n  }\r\n  return createEvent('audio', 'note', props);\r\n};\r\n\r\nmodule.exports = {\r\n  class: evClass,\r\n  type: evType,\r\n  property: evProp,\r\n  createAudioNote: createAudioNote\r\n};\r\n","'use strict';\r\n\r\nvar core = require('./core.js');\r\n\r\n/**\r\n * <p>\r\n * Creates a wrapper in which an audio buffer lives.\r\n * A SoundWave object just holds audio data and does nothing else.\r\n * If you want to play the sound, you have to additionally create a\r\n * <a href=\"Sound.html\">Sound</a> object.\r\n * It can handle one or more ArrayBuffers or filenames\r\n * (*.wav, *.mp3) as data sources.\r\n * </p><p>\r\n * Multiple sources will be concatenated into one audio buffer.\r\n * This is not the same as creating multiple SoundWave objects.\r\n * It's like a wavetable: All start/end positions will be saved so\r\n * you can trigger the original samples without using multiple buffers.\r\n * Possible usages are multisampled sounds, loops or wavesequences (kind of).\r\n * </p>\r\n *\r\n * @example <caption>Play a sound from an audio file:</caption>\r\n * var soundWave = new intermix.SoundWave('file.wav');\r\n * var sound = new intermix.Sound(soundWave);\r\n * sound.play;\r\n * @example <caption>Concatenate multiple source files into one buffer<br>\r\n * in the given order and play them (This is broken in v0.1. Don't use it!):</caption>\r\n * var soundWave = new intermix.SoundWave('file1.wav,file2.wav,file3.wav');\r\n * var sound = new intermix.Sound(soundWave);\r\n * sound.play;\r\n * @example <caption>\r\n * Using ArrayBuffers instead of filenames will come in handy if you want<br>\r\n * to have full control over XHR or use a preloader (here: preload.js):\r\n * </caption>\r\n * var queue = new createjs.LoadQueue();\r\n * queue.on('complete', handleComplete);\r\n * queue.loadManifest([\r\n *     {id: 'src1', src:'file1.wav', type:createjs.AbstractLoader.BINARY},\r\n *     {id: 'src2', src:'file2.wav', type:createjs.AbstractLoader.BINARY}\r\n * ]);\r\n *\r\n * function handleComplete() {\r\n *     var binData1 = queue.getResult('src1');\r\n *     var binData2 = queue.getResult('src2');\r\n *     var wave1 = new intermix.SoundWave(binData1);\r\n *     var wave2 = new intermix.SoundWave(binData2);\r\n *     var concatWave = new intermix.SoundWave([binData1, binData2]);\r\n * };\r\n * @constructor\r\n * @param  {(Object|Object[]|string)} audioSrc   One or more ArrayBuffers or filenames\r\n */\r\nvar SoundWave = function(audioSrc) {\r\n  var self = this;\r\n  this.ac = core;       //currently just used for tests\r\n  this.buffer = core.createBuffer(1, 0, core.sampleRate);   //AudioBuffer\r\n  this.metaData = [];   //start-/endpoints and length of single waves\r\n\r\n  if (typeof audioSrc !== 'undefined') {\r\n    if (typeof audioSrc === 'string') {\r\n      //one file to load/decode\r\n      this.buffer = this.loadFile(audioSrc).then(function(response) {\r\n        return self.decodeAudioData(response);\r\n      })\r\n      .then(function(decoded) {\r\n        self.buffer = decoded;\r\n        return self.buffer;\r\n      })\r\n      .catch(function(err) {\r\n        throw err;\r\n      });\r\n    } else if (audioSrc instanceof Array && typeof audioSrc[0] === 'string') {\r\n      //multiple files to load/decode and cancatinate\r\n      this.buffer = this.loadMultipleFiles(audioSrc).then(function(decoded) {\r\n        self.buffer = decoded;\r\n      })\r\n      .catch(function(err) {\r\n        throw err;\r\n      });\r\n    } else if (audioSrc instanceof ArrayBuffer) {\r\n      //one ArrayBuffer to decode\r\n      this.buffer = this.decodeAudioData(audioSrc);\r\n    } else if (audioSrc instanceof Array && audioSrc[0] instanceof ArrayBuffer) {\r\n      //multiple ArrayBuffers to decode and concatenate\r\n      this.decodeAudioSources(audioSrc).then(function(audioBuffers) {\r\n        return self.joinAudioBuffers(audioBuffers);\r\n      })\r\n      .then(function(audioBuffer) {\r\n        this.buffer = audioBuffer;\r\n      });\r\n    } else {\r\n      throw new Error('Cannot create SoundWave object: Unsupported data format');\r\n    }\r\n  } else {\r\n    //start the object with empty buffer. Usefull for testing and advanced usage.\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * Takes an array of filenames and returns a promise that resolves\r\n * to an AudioBuffer including the PCM data of all files on success.\r\n * Returns an error on failure.\r\n * @param  {Array}    filenames Array with filenames to be loaded\r\n * @return {Promise}            Resolves to AudioBuffer or throws error.\r\n */\r\nSoundWave.prototype.loadMultipleFiles = function(urls) {\r\n  var self = this;\r\n  var filenames = this.stripFilenames(urls);\r\n\r\n  return this.loadFiles(urls).then(function(binBuffers) {\r\n    return self.decodeAudioSources(binBuffers);\r\n  })\r\n  .then(function(audioBuffers) {\r\n    var promises = [];\r\n    promises.push(self.joinAudioBuffers(audioBuffers),\r\n      self.storeMetaData(audioBuffers, filenames));\r\n    return Promise.all(promises);\r\n  })\r\n  .then(function(bufferAndMeta) {\r\n    self.metaData = bufferAndMeta[1];\r\n    return bufferAndMeta[0];\r\n  })\r\n  .catch(function(err) {\r\n    throw err;\r\n  });\r\n};\r\n\r\n/**\r\n * Takes one or more ArrayBuffers and returns an equal number of AudioBuffers.\r\n * @param  {Array}    buffers Array with ArrayBuffers\r\n * @return {Promise}          Resolves to an array of AudioBuffers or error\r\n */\r\nSoundWave.prototype.decodeAudioSources = function(buffers) {\r\n  var promises = [];\r\n  buffers.forEach(function(buffer) {\r\n    promises.push(this.decodeAudioData(buffer));\r\n  }, this);\r\n\r\n  return Promise.all(promises);\r\n};\r\n\r\n/**\r\n * Takes an ArrayBuffer with binary audio data and\r\n * turns it into an audio buffer object.\r\n * Just a wrapper for the web-audio-api decodeAudioData function.\r\n * It uses the new promise syntax so it probably won't work in all browsers by now.\r\n * @private\r\n * @param  {ArrayBuffer}  rawAudioSrc Audio data in raw binary format\r\n * @return {Promise}                  Resolves to AudioBuffer or error\r\n */\r\nSoundWave.prototype.decodeAudioData = function(rawAudioSrc) {\r\n  return core.decodeAudioData(rawAudioSrc);\r\n};\r\n\r\n/**\r\n * Joins an arbitrary number of ArrayBuffers.\r\n * @private\r\n * @param  {Array}       buffers Array of AudioBuffers\r\n * @return {AudioBuffer}         Waveform that includes all given buffers.\r\n */\r\nSoundWave.prototype.joinAudioBuffers = function(buffers) {\r\n  var self = this;\r\n  var joinedBuffer = core.createBuffer(1, 0, core.sampleRate);\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    buffers.forEach(function(buffer) {\r\n      if (buffer instanceof window.AudioBuffer) {\r\n        joinedBuffer = this.appendAudioBuffer(joinedBuffer, buffer);\r\n      } else {\r\n        reject(new TypeError('One or more buffers are not of type AudioBuffer.'));\r\n      }\r\n    }, self);\r\n    resolve(joinedBuffer);\r\n  });\r\n};\r\n\r\n/**\r\n * Appends two audio buffers. Both buffers should have the same amount\r\n * of channels. If not, channels will be dropped. For example, if you\r\n * append a stereo and a mono buffer, the output will be mono and only\r\n * one of the channels of the stereo sample will be used (no merging of channels).\r\n * Suggested by Chris Wilson:<br>\r\n * http://stackoverflow.com/questions/14143652/web-audio-api-append-concatenate-different-audiobuffers-and-play-them-as-one-son\r\n * @private\r\n * @param  {AudioBuffer} buffer1 The first audio buffer\r\n * @param  {AudioBuffer} buffer2 The second audio buffer\r\n * @return {AudioBuffer}         buffer1 + buffer2\r\n */\r\nSoundWave.prototype.appendAudioBuffer = function(buffer1, buffer2) {\r\n  if (buffer1 instanceof window.AudioBuffer &&\r\n  buffer2 instanceof window.AudioBuffer) {\r\n    var numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);\r\n    var newBuffer = core.createBuffer(numberOfChannels,\r\n      (buffer1.length + buffer2.length),\r\n      buffer1.sampleRate);\r\n    for (var i = 0; i < numberOfChannels; i++) {\r\n      var channel = newBuffer.getChannelData(i);\r\n      channel.set( buffer1.getChannelData(i), 0);\r\n      channel.set( buffer2.getChannelData(i), buffer1.length);\r\n    }\r\n    return newBuffer;\r\n  } else {\r\n    throw new TypeError('One or both buffers are not of type AudioBuffer.');\r\n  }\r\n};\r\n\r\n/**\r\n * Stores metaData objects in the metaData array.\r\n * @param  {Array} audioBuffers Array of AudioBuffers\r\n * @param  {Array} names        Array of names\r\n * @return {Promise}            Resolves to a metaData array or error.\r\n */\r\nSoundWave.prototype.storeMetaData = function(audioBuffers, names) {\r\n  var fnames = [];\r\n  var metaData = [];\r\n  var start = 0;\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    if (typeof names === 'undefined') {\r\n      audioBuffers.forEach(function(buffer, index) {\r\n        fnames.push('fragment' + index);\r\n      });\r\n    } else if (names.length === audioBuffers.length) {\r\n      fnames = names;\r\n    } else {\r\n      reject(new Error('audioBuffers and names should be of same length'));\r\n    }\r\n    audioBuffers.forEach(function(buffer, index) {\r\n      metaData.push(this.getMetaData(buffer, names[index], start));\r\n      start += buffer.length;\r\n    }, self);\r\n    resolve(metaData);\r\n  });\r\n};\r\n\r\n/**\r\n * Strips filenames from an array of urls and returns it in an array.\r\n * @private\r\n * @param  {Array} urls Array of urls\r\n * @return {Array}      Array of filenames\r\n */\r\nSoundWave.prototype.stripFilenames = function(urls) {\r\n  return urls.map(function(url) {\r\n    return url.split('/').pop();\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a dictionary with start/stop points and length in sample-frames\r\n * of a buffer fragment..\r\n * @param  {AudioBuffer} buffer      Buffer with the appendable pcm fragment\r\n * @param  {String}      name        Name of the fragment\r\n * @param  {Int}         start       Startpoint of the fragment\r\n * @return {Object}                  Dictionary with meta data or error msg\r\n */\r\nSoundWave.prototype.getMetaData = function(buffer, name, start) {\r\n  if (buffer instanceof window.AudioBuffer && typeof name === 'string') {\r\n    if (typeof start === 'undefined') {\r\n      start = 0;\r\n    }\r\n    var bufLength = buffer.length;\r\n    return {\r\n      'name': name,\r\n      'start': start,\r\n      'end': start + bufLength - 1,\r\n      'length': bufLength\r\n    };\r\n  } else {\r\n    throw new TypeError('Arguments should be of type AudioBuffer and String');\r\n  }\r\n};\r\n\r\n/**\r\n * Loads a (audio) file and returns its data as ArrayBuffer\r\n * when the promise fulfills.\r\n * @private\r\n * @param  {string}   url            The file to be loaded\r\n * @return {Promise}                 A promise representing the xhr response\r\n */\r\nSoundWave.prototype.loadFile = function(url) {\r\n  return window.fetch(url)\r\n    .then(function(response) {\r\n      if (response.ok) {\r\n        return response.arrayBuffer();\r\n      } else {\r\n        throw new Error('Server error. Couldn\\'t load file: ' + url);\r\n      }\r\n    });\r\n};\r\n\r\n/**\r\n * Loads multiple (audio) files and returns an array\r\n * with the data from the files in the given order.\r\n * @private\r\n * @param  {Array}  filenames List with filenames\r\n * @return {Array}            Array of ArrayBuffers\r\n */\r\nSoundWave.prototype.loadFiles = function(filenames) {\r\n  var promises = [];\r\n  filenames.forEach(function(name) {\r\n    promises.push(this.loadFile(name));\r\n  }, this);\r\n\r\n  return Promise.all(promises);\r\n};\r\n\r\n\r\n/**\r\n * Get an AudioBuffer with a fragment of the AudioBuffer\r\n * of this object.\r\n * @param  {Int}    start   Startpoint of the fragment in samples\r\n * @param  {Int}    end     Endpoint of the fragment in samples\r\n * @return {AudioBuffer}    AudioBuffer including the fragment\r\n */\r\nSoundWave.prototype.getBufferFragment = function(start, end) {\r\n  if (this.buffer.length === 0) {\r\n    throw new Error('Audio buffer empty. Nothing to copy.');\r\n  } else if (typeof start === 'undefined') {\r\n    return this.buffer;\r\n  } else if (start < 0) {\r\n    start = 0;\r\n  }\r\n\r\n  if (typeof end === 'undefined' || end > this.buffer.length) {\r\n    end = this.buffer.length;\r\n  }\r\n\r\n  if (start >= end) {\r\n    throw new Error('Arguments out of bounds.');\r\n  }\r\n\r\n  var chnCount = this.buffer.numberOfChannels;\r\n  var frameCount = end - start;\r\n  var newBuffer = core.createBuffer(chnCount, frameCount, core.sampleRate);\r\n\r\n  for (var chn = 0; chn < chnCount; chn++) {\r\n    var newChannel = newBuffer.getChannelData(chn);\r\n    var oldChannel = this.buffer.getChannelData(chn);\r\n\r\n    for (var i = 0; i < frameCount; i++) {\r\n      newChannel[i] = oldChannel[start + i];\r\n    }\r\n  }\r\n\r\n  return newBuffer;\r\n};\r\n\r\n/**\r\n * Sort ArrayBuffers the same order, like the filename\r\n * parameters.\r\n * @private\r\n * @param  {Array}  filenames  Array with filenames\r\n * @param  {Array}  binBuffers Array with ArrayBuffer\r\n * @return {Array}             Array with sorted ArrayBuffers\r\n */\r\nSoundWave.prototype.sortBinBuffers = function(filenames, binBuffers) {\r\n  // futile??\r\n  return filenames.map(function(el) {\r\n    return binBuffers[el];\r\n  });\r\n};\r\n\r\nmodule.exports = SoundWave;\r\n","'use strict';\r\n\r\nvar core = require('./core.js');\r\n\r\n/**\r\n * <p>\r\n * Play a sound that can be looped. Pause/Start works sample-accurate\r\n * at any rate. Hit the start button multiple times to have multiple\r\n * sounds played. All parameters are adjustable in realtime.\r\n * </p>\r\n *\r\n * @example\r\n * var soundWave = new intermix.SoundWave('audiofile.wav');\r\n * var sound = new intermix.Sound(soundWave);\r\n * sound.start();\r\n * @tutorial Sound\r\n * @constructor\r\n * @param  {Object} soundWave SoundWave object including the buffer with audio data to be played\r\n */\r\nvar Sound = function(soundWave) {\r\n\r\n  this.wave = null;\r\n  this.ac = core;           //currently just used for tests\r\n  this.queue = [];          //all currently active streams\r\n  this.loop = false;\r\n  this.gainNode = null;\r\n  this.pannerNode = null;\r\n\r\n  this.soundLength = 0;\r\n  this.isPaused = false;\r\n  this.startOffset = 0;\r\n  this.startOffsets = [];   //holds start offsets if paused\r\n  this.startTime = 0;       //when the sound starts to play\r\n  this.loopStart = 0;\r\n  this.loopEnd = null;\r\n  this.playbackRate = 1;\r\n  this.detune = 0;\r\n\r\n  if (soundWave) {\r\n    this.wave = soundWave;\r\n    this.soundLength = this.loopEnd = this.wave.buffer.duration;\r\n    this.setupAudioChain();\r\n  } else {\r\n    throw new Error('Error initialising Sound object: parameter missing.');\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a gain and stereo-panner node, connects them\r\n * (gain -> panner) and sets gain to 1 (max value).\r\n * @private\r\n * @return {Void}\r\n */\r\nSound.prototype.setupAudioChain = function() {\r\n  this.gainNode = core.createGain();\r\n  this.pannerNode = core.createStereoPanner();\r\n  this.gainNode.connect(this.pannerNode);\r\n  this.pannerNode.connect(core.destination);\r\n  this.gainNode.gain.value = 1;\r\n};\r\n\r\n/**\r\n * Creates and configures a BufferSourceNode\r\n * that can be played once and then destroys itself.\r\n * @private\r\n * @return {BufferSourceNode} The BufferSourceNode\r\n */\r\nSound.prototype.createBufferSource = function() {\r\n  var self = this;\r\n  var bufferSource = core.createBufferSource();\r\n  // console.log(this.wave.buffer);\r\n  bufferSource.buffer = this.wave.buffer;\r\n  bufferSource.connect(this.gainNode);\r\n  bufferSource.onended = function() {\r\n    //console.log('onended fired');\r\n    self.destroyBufferSource(bufferSource);\r\n  };\r\n  return bufferSource;\r\n};\r\n\r\n/**\r\n * Destroyes a given AudioBufferSourceNode and deletes it\r\n * from the sourceNode queue. This is used in the onended\r\n * callback of all BufferSourceNodes to avoid dead references.\r\n * @private\r\n * @param  {bsNode} bsNode the bufferSource to be destroyed.\r\n */\r\nSound.prototype.destroyBufferSource = function(bsNode) {\r\n  bsNode.disconnect();\r\n  this.queue.forEach(function(node, index) {\r\n    if (node === bsNode) {\r\n      this.queue.splice(index, 1);\r\n    }\r\n  }, this);\r\n};\r\n\r\n/**\r\n * Starts a sound (AudioBufferSourceNode) and stores a references\r\n * in a queue. This enables you to play multiple sounds at once\r\n * and even stop them all at a given time.\r\n * @param  {Boolean} playLooped Whether the sound should be looped or not\r\n * @param  {float}   delay      Time in seconds the sound pauses before the stream starts\r\n * @param  {float}   duration   Time preriod after the stream should end\r\n * @return {Void}\r\n */\r\nSound.prototype.start = function(playLooped, delay, duration) {\r\n  if (this.isPaused && this.queue.length > 0) {\r\n    this.resume();\r\n  } else {\r\n    var startTime = 0;\r\n\r\n    if (delay) {\r\n      startTime = delay;\r\n    } else {\r\n      startTime = core.currentTime;\r\n    }\r\n    var bs = this.createBufferSource();\r\n\r\n    if (playLooped) {\r\n      bs.loop = playLooped;\r\n      bs.loopStart = this.loopStart;\r\n      bs.loopEnd = this.loopEnd;\r\n    }\r\n    bs.playbackRate.value = bs.tmpPlaybackRate = this.playbackRate;\r\n    bs.detune.value = this.detune;\r\n    bs.startTime = startTime;   // extend node with a starttime property\r\n\r\n    this.queue.push(bs);\r\n    if (duration) {\r\n      bs.start(startTime, this.startOffset, duration);\r\n    } else {\r\n      bs.start(startTime, this.startOffset);\r\n    }\r\n\r\n    this.startOffset = 0;\r\n  }\r\n};\r\n\r\n/**\r\n * Stops all audio stream, even the ones that are just scheduled.\r\n * It also cleans the queue so that the sound object is ready for another round.\r\n * @return {Void}\r\n */\r\nSound.prototype.stop = function() {\r\n  this.queue.forEach(function(node) {\r\n    node.stop();\r\n    node.disconnect();\r\n  });\r\n  this.queue = [];  //release all references\r\n};\r\n\r\n/**\r\n * Stops all audio streams of this sound temporarily.\r\n * This currently just works in Chrome 49+ only.\r\n * If you want a global, accurate pause function\r\n * use suspend/resume from the core module.\r\n * @return  {Void}\r\n */\r\nSound.prototype.pause = function() {\r\n  if (!this.isPaused) {\r\n    this.queue.forEach(function(node) {\r\n      node.tmpPlaybackRate = node.playbackRate.value;\r\n      node.playbackRate.value = 0.0;\r\n    });\r\n    this.isPaused = true;\r\n  }\r\n};\r\n\r\n/**\r\n * Resumes all streams if they were paused.\r\n * @return {Void}\r\n */\r\nSound.prototype.resume = function() {\r\n  this.queue.forEach(function(node) {\r\n    node.playbackRate.value = node.tmpPlaybackRate;\r\n    delete node.tmpPlaybackRate;\r\n  });\r\n  this.isPaused = false;\r\n};\r\n\r\n/**\r\n * Processes an event fired by the sequencer.\r\n * @param  {Object} seqEvent A sequencer event\r\n * @return {Void}\r\n */\r\nSound.prototype.processSeqEvent = function(seqEvent) {\r\n  //this.setTone(seqEvent.props.tone);\r\n  if (seqEvent.props.duration) {\r\n    this.start(false,\r\n      seqEvent.props.delay,\r\n      seqEvent.props.duration);\r\n  } else {\r\n    this.start(false,\r\n      seqEvent.props.delay);\r\n  }\r\n};\r\n\r\n/**\r\n * Sets the startpoint of the loop\r\n * @param  {float} value  loop start in seconds\r\n * @return {Void}\r\n */\r\nSound.prototype.setLoopStart = function(value) {\r\n  this.loopStart = value;\r\n  this.queue.forEach(function(node) {\r\n    node.loopStart = value;\r\n  });\r\n};\r\n\r\n/**\r\n * Sets the endpoint of the loop\r\n * @param  {float} value  loop end in seconds\r\n * @return {Void}\r\n */\r\nSound.prototype.setLoopEnd = function(value) {\r\n  this.loopEnd = value;\r\n  this.queue.forEach(function(node) {\r\n    node.loopEnd = value;\r\n  });\r\n};\r\n\r\n/**\r\n * Releases the loop of all running nodes,\r\n * Nodes will run until end and stop.\r\n * @return {Void}\r\n */\r\nSound.prototype.releaseLoop = function() {\r\n  this.queue.forEach(function(node) {\r\n    node.loop = false;\r\n  });\r\n};\r\n\r\n/**\r\n * Resets the start and endpoint to start end endpoint of the AudioBuffer\r\n * @return {Void}\r\n */\r\nSound.prototype.resetLoop = function() {\r\n  this.loopStart = 0;\r\n  this.loopEnd = this.soundLength;\r\n};\r\n\r\n/**\r\n * Set the playback rate of the sound in percentage\r\n * (1 = 100%, 2 = 200%)\r\n * @param  {float}  value   Rate in percentage\r\n * @return {Void}\r\n */\r\nSound.prototype.setPlaybackRate = function(value) {\r\n  this.playbackRate = value;\r\n  this.queue.forEach(function(node) {\r\n    node.playbackRate.value = value;\r\n  });\r\n};\r\n\r\n/**\r\n * Get the current playback rate\r\n * @return {float}  The playback rate in percentage (1.25 = 125%)\r\n */\r\nSound.prototype.getPlaybackRate = function() {\r\n  return this.playbackRate;\r\n};\r\n\r\n/**\r\n * Set the tone within two octave (+/-12 tones)\r\n * @param  {Integer}  semi tone\r\n * @return {Void}\r\n */\r\nSound.prototype.setTone = function(semiTone) {\r\n  if (semiTone >= -12 && semiTone <= 12) {\r\n    this.detune = semiTone * 100;\r\n  } else {\r\n    throw new Error('Semi tone is ' + semiTone + '. Must be between +/-12.');\r\n  }\r\n};\r\n\r\n/**\r\n * Get the last played semitone. This doesn't has to be an\r\n * integer between -/+12 as the sound can be detuned with\r\n * more precision.\r\n * @return {float}  Semitone between -/+12\r\n */\r\nSound.prototype.getTone = function() {\r\n  return this.detune / 100;\r\n};\r\n\r\n/**\r\n * Detune the sound oscillation in cents (+/- 1200)\r\n * @param  {Integer}  value  detune in cents\r\n * @return {Void}\r\n */\r\nSound.prototype.setDetune = function(value) {\r\n  if (value >= -1200 && value <= 1200) {\r\n    this.detune = value;\r\n  } else {\r\n    throw new Error('Detune parameter is ' + value + '. Must be between +/-1200.');\r\n  }\r\n};\r\n\r\n/**\r\n * get the current detune in cents (+/- 1200)\r\n * @return {Integer}  Detune in cents\r\n */\r\nSound.prototype.getDetune = function() {\r\n  return this.detune;\r\n};\r\n\r\n/**\r\n * This is not in use and can probably be removed\r\n * @return {Int} Random number\r\n */\r\nSound.prototype.getUID = function() {\r\n  return Math.random().toString().substr(2, 8);\r\n};\r\n\r\nmodule.exports = Sound;\r\n","'use strict';\r\n\r\n/**\r\n * Represents a part of a sequence. It can be\r\n * used in many ways:\r\n * <ul>\r\n * <li>A part of a track like in piano-roll sequencers</li>\r\n * <li>A pattern like in step sequencers, drum computers and trackers</li>\r\n * <li>A loop like in live sequencers</li>\r\n * </ul>\r\n * Technically it can store any type of event your system is capable of.\r\n * This means it is not limited to audio, midi, osc or dmx but can hold\r\n * any type of javascript object. A possible usecase would be to trigger\r\n * screen events with the draw function of the sequencer object.\r\n * @example\r\n * var sound = new intermix.Sound(soundWaveObject);\r\n * var seq = new intermix.Sequencer();\r\n * var part = new intermix.Part();\r\n * var note = intermix.events.createAudioNote('a3', 1, 0, sound);\r\n * part.addEvent(note, 0);\r\n * part.addEvent(note, 4);\r\n * seq.addPart(part, 0);\r\n * @constructor\r\n * @param  {float}  length       Length of the part in 64th notes (default: 64)\r\n */\r\nvar Part = function(length) {\r\n\r\n  this.resolution = 16; // (resolution * multiply) should alwasy be 64\r\n  this.multiply = 4;    // resolution multiplier\r\n  this.length = 64;     // length of the pattern in 64th notes\r\n  this.name = 'Part';   // name of this part\r\n  this.pattern = [];    // the actual pattern with notes etc.\r\n\r\n  if (length) {\r\n    this.length = length;\r\n  }\r\n\r\n  this.pattern = this.initPattern(this.length);\r\n};\r\n\r\n/**\r\n * Initialize an empty pattern for the part.\r\n * @private\r\n * @param  {float}  length  Length of the pattern mesured in bars (4 beats = 1 bar)\r\n * @return {Object} The current context to make the function chainable.\r\n */\r\nPart.prototype.initPattern = function(length) {\r\n  var pattern = [];\r\n  for (var i = 0; i < (length); i++) {\r\n    pattern[i] = [];\r\n  }\r\n  return pattern;\r\n};\r\n\r\n/**\r\n * Adds an event to the pattern at a given position\r\n * @param  {Object} seqEvent  The event (note, controller, whatever)\r\n * @param  {Int}    position  Position in the pattern\r\n * @return {Object} The current context to make the function chainable.\r\n */\r\nPart.prototype.addEvent = function(seqEvent, position) {\r\n  if (position <= this.resolution) {\r\n    var pos = (position) * this.multiply;\r\n    this.pattern[pos].push(seqEvent);\r\n  } else {\r\n    throw new Error('Position out of pattern bounds.');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes an event at a given position\r\n * @param  {Object} seqEvent  The event (note, controller, whatever)\r\n * @param  {Int}    position  Position in the pattern\r\n * @return {Void}\r\n */\r\nPart.prototype.removeEvent = function(seqEvent, position) {\r\n  var pos = (position) * this.multiply;\r\n  var index = this.pattern[pos].indexOf(seqEvent);\r\n  this.pattern[pos].splice(index, 1);\r\n};\r\n\r\n/**\r\n * Get the length of the pattern in 64th notes\r\n * @return {Int}    Length of the pattern\r\n */\r\nPart.prototype.getLength = function() {\r\n  return this.pattern.length;\r\n};\r\n\r\n/**\r\n * Get all positions that contain at least one event.\r\n * Can be handy to draw events on the screen.\r\n * @example <caption>from {@tutorial Stepsequencer}</caption>\r\n * bdSteps = bdPart.getNotePositions();\r\n * bdSteps.forEach(function(pos) {\r\n *   document.getElementById('bd' + pos).style.backgroundColor = 'red';\r\n * });\r\n * @return {Array}  List with all non-empty pattern entries\r\n */\r\nPart.prototype.getNotePositions = function() {\r\n  var positions = [];\r\n  this.pattern.forEach(function(el, index) {\r\n    if (el.length > 0) {\r\n      positions.push(index / this.multiply);\r\n    }\r\n  }, this);\r\n  return positions;\r\n};\r\n\r\n/**\r\n * Extends a part at the top/start.\r\n * @param  {float}  extLength Length in 64th notes\r\n * @return {Void}\r\n */\r\nPart.prototype.extendOnTop = function(extLength) {\r\n  var extension = this.initPattern(extLength);\r\n  this.pattern = extension.concat(this.pattern);\r\n};\r\n\r\n/**\r\n * Extends a part at the end\r\n * @param  {float}  extLength Length in 64th notes\r\n * @return {Void}\r\n */\r\nPart.prototype.extendOnEnd = function(extLength) {\r\n  var extension = this.initPattern(extLength);\r\n  this.pattern = this.pattern.concat(extension);\r\n};\r\n\r\nmodule.exports = Part;\r\n","'use strict';\r\n\r\nvar work = require('webworkify');   //prepares the worker for browserify\r\nvar core = require('./core.js');\r\nvar worker = require('./scheduleWorker.js');\r\n\r\n/**\r\n * The main class of the sequencer. It does the queuing of\r\n * parts and events and runs the schedulers that fire events\r\n * and draws to the screen.\r\n * @example\r\n * var part = new intermix.Part();\r\n * var seq = new intermix.Sequencer();\r\n * part.addEvent(someNote, 0);\r\n * seq.addPart(part, 0);\r\n * seq.start();\r\n * @constructor\r\n */\r\nvar Sequencer = function() {\r\n\r\n  var self = this;\r\n  this.ac = core;             //currently just used for tests\r\n  this.bpm = 120;             //beats per minute\r\n  this.resolution = 64;       //shortest possible note. You normally don't want to touch this.\r\n  this.interval = 100;        //the interval in miliseconds the scheduler gets invoked.\r\n  this.lookahead = 0.3;       //time in seconds the scheduler looks ahead.\r\n                              //should be longer than interval.\r\n  this.queue = [];            //List with all parts of the score\r\n  this.runqueue = [];         //list with parts that are playing or will be played shortly\r\n\r\n  this.timePerStep;           //period of time between two steps\r\n  this.nextStepTime = 0;      //time in seconds when the next step will be triggered\r\n  this.nextStep = 0;          //position in the queue that will get triggered next\r\n  this.lastPlayedStep = 0;    //step in queue that was played (not triggered) recently (used for drawing).\r\n  this.loop = false;          //play a section of the queue in a loop\r\n  this.loopStart;             //first step of the loop\r\n  this.loopEnd;               //last step of the loop\r\n  this.isRunning = false;     //true if sequencer is running, otherwise false\r\n  this.animationFrame;        //has to be overridden with a function. Will be called in the\r\n                              //draw function with the lastPlayedStep int as parameter.\r\n\r\n  // set time per setTimePerStep\r\n  this.timePerStep = this.setTimePerStep(this.bpm, this.resolution);\r\n\r\n  // Initialize the scheduler-timer\r\n  this.scheduleWorker = work(worker);\r\n\r\n  /*eslint-enable */\r\n\r\n  this.scheduleWorker.onmessage = function(e) {\r\n    if (e.data === 'tick') {\r\n      self.scheduler();\r\n    }\r\n  };\r\n\r\n  this.scheduleWorker.postMessage({'interval': this.interval});\r\n};\r\n\r\n/**\r\n * Reads events from the master queue and fires them.\r\n * It gets called at a constant rate, looks ahead in\r\n * the queue and fires all events in the near future\r\n * with a delay computed from the current bpm value.\r\n * @private\r\n * @return {Void}\r\n */\r\nSequencer.prototype.scheduler = function() {\r\n  var limit = core.currentTime + this.lookahead;\r\n  // if invoked for the first time or previously stopped\r\n  if (this.nextStepTime === 0) {\r\n    this.nextStepTime = core.currentTime;\r\n  }\r\n\r\n  while (this.nextStepTime < limit) {\r\n    this.addPartsToRunqueue();\r\n    this.fireEvents();\r\n    this.nextStepTime += this.timePerStep;\r\n\r\n    this.setQueuePointer();\r\n  }\r\n};\r\n\r\n/**\r\n * Looks in the master queue for parts and adds\r\n * copies of them to the runqueue.\r\n * @private\r\n * @return {Void}\r\n */\r\nSequencer.prototype.addPartsToRunqueue = function() {\r\n  if (typeof this.queue[this.nextStep] !== 'undefined') {\r\n    if (this.queue[this.nextStep].length === 1) {\r\n      var part = this.queue[this.nextStep][0];\r\n      part.pointer = 0;\r\n      this.runqueue.push(part);\r\n    } else {\r\n      this.queue[this.nextStep].forEach(function(part) {\r\n        part.pointer = 0;\r\n        this.runqueue.push(part);\r\n      }, this);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Deletes parts from runqueue. It is important, that the indices\r\n * of the parts are sorted from max to min. Otherwise the forEach\r\n * loop won't work.\r\n * @private\r\n * @param  {Array} indices  Indices of the parts in the runqueue\r\n * @return {Void}\r\n */\r\nSequencer.prototype.deletePartsFromRunqueue = function(indices) {\r\n  if (indices.length > 0) {\r\n    indices.forEach(function(id) {\r\n      delete this.runqueue[id].pointer;\r\n      this.runqueue.splice(id, 1);\r\n    }, this);\r\n  }\r\n};\r\n\r\n/**\r\n * Fires all events for the upcomming step.\r\n * @private\r\n * @return {Void}\r\n */\r\nSequencer.prototype.fireEvents = function() {\r\n  var markForDelete = [];\r\n  this.runqueue.forEach(function(part, index) {\r\n    if (part.pointer === part.length - 1) {\r\n      markForDelete.unshift(index);\r\n    } else {\r\n      var seqEvents = part.pattern[part.pointer];\r\n      if (seqEvents && seqEvents.length > 1) {\r\n        seqEvents.forEach(function(seqEvent) {\r\n          this.processSeqEvent(seqEvent, this.nextStepTime);\r\n        }, this);\r\n      } else if (seqEvents && seqEvents.length === 1) {\r\n        this.processSeqEvent(seqEvents[0], this.nextStepTime);\r\n      }\r\n    }\r\n    part.pointer++;\r\n  }, this);\r\n  this.deletePartsFromRunqueue(markForDelete);\r\n};\r\n\r\n/**\r\n * Invokes the appropriate subsystem to process the event\r\n * @private\r\n * @param  {Object} seqEvent  The event to process\r\n * @param  {float}  delay     time in seconds when the event should start\r\n * @return {Void}\r\n */\r\nSequencer.prototype.processSeqEvent = function(seqEvent, delay) {\r\n  if (delay) {\r\n    seqEvent.props['delay'] = delay;\r\n  }\r\n  seqEvent.props.instrument.processSeqEvent(seqEvent);\r\n};\r\n\r\n/**\r\n * Sets the pointer to the next step that should be played\r\n * in the master queue. If we're playing in loop mode,\r\n * jump back to loopstart when end of loop is reached.\r\n * If a pointer position is given, jump to it.\r\n * @private\r\n * @param   {Int}   position  New position in the master queue\r\n * @return  {Void}\r\n */\r\nSequencer.prototype.setQueuePointer = function(position) {\r\n  if (typeof position !== 'undefined') {\r\n    this.nextStep = position;\r\n    this.runqueue = [];\r\n  } else if (this.loop && this.nextStep >= this.loopEnd) {\r\n    this.nextStep = this.loopStart;\r\n    this.runqueue = [];\r\n  } else {\r\n    this.nextStep++;\r\n  }\r\n};\r\n\r\n/**\r\n * Resets the queue pointer (set to position 0).\r\n * @return {Void}\r\n */\r\nSequencer.prototype.resetQueuePointer = function() {\r\n  this.setQueuePointer(0);\r\n};\r\n\r\n/**\r\n * Starts the sequencer\r\n * @return {Void}\r\n */\r\nSequencer.prototype.start = function() {\r\n  if (!this.isRunning) {\r\n    this.scheduleWorker.postMessage('start');\r\n    this.isRunning = true;\r\n    window.requestAnimationFrame(this.draw.bind(this));\r\n  }\r\n};\r\n\r\n/**\r\n * Stops the sequencer (halts at the current position)\r\n * @return {Void}\r\n */\r\nSequencer.prototype.stop = function() {\r\n  this.scheduleWorker.postMessage('stop');\r\n  this.nextStepTime = 0;\r\n  this.isRunning = false;\r\n};\r\n\r\n/**\r\n * Stops the sequencer and suspends the AudioContext to\r\n * globally halt all audio streams. It just halts if\r\n * if sequencer and AudioContext both are in running state.\r\n * @return {Boolean} true if halted, false if not\r\n */\r\nSequencer.prototype.pause = function() {\r\n  if (core.state === 'running' && this.isRunning) {\r\n    this.stop();\r\n    core.suspend();\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Resumes the AudioContext and starts the sequencer at its\r\n * current position. It just starts if sequencer and AudioContext\r\n * both are stopped.\r\n * @return {Boolean} true if resumed, false if not\r\n */\r\nSequencer.prototype.resume = function() {\r\n  if (core.state === 'suspended' && !this.isRunning) {\r\n    this.start();\r\n    core.resume();\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Scheduler that runs a drawing function every time\r\n * the screen refreshes. The function Sequencer.animationFrame()\r\n * has to be overridden by the application with stuff to be drawn on the screen.\r\n * It calls itself recursively on every frame as long as the sequencer is running.\r\n * @private\r\n * @return {Void}\r\n */\r\nSequencer.prototype.draw = function() {\r\n  // first we'll have to find out, what step was played recently.\r\n  // this is somehow clumsy because the sequencer doesn't keep track of that.\r\n  var lookAheadDelta = this.nextStepTime - core.currentTime;\r\n  if (lookAheadDelta >= 0) {\r\n    var stepsAhead = Math.round(lookAheadDelta / this.timePerStep);\r\n\r\n    if (this.nextStep < stepsAhead) {\r\n      // we just jumped to the start of a loop\r\n      this.lastPlayedStep = this.loopEnd + this.nextStep - stepsAhead;\r\n    } else {\r\n      this.lastPlayedStep = this.nextStep - stepsAhead;\r\n    }\r\n\r\n    this.updateFrame(this.lastPlayedStep);\r\n  }\r\n\r\n  if (this.isRunning) {\r\n    window.requestAnimationFrame(this.draw.bind(this));\r\n  }\r\n};\r\n\r\n/**\r\n * Runs between screen refresh. Has to be overridden by the\r\n * app to render to the screen.\r\n * @param  {Int}  lastPlayedStep  The 64th step that was played recently\r\n * @return {Void}\r\n */\r\nSequencer.prototype.updateFrame = function(lastPlayedStep) {\r\n  console.log(lastPlayedStep);\r\n};\r\n\r\n/**\r\n * Adds a part to the master queue.\r\n * @param  {Object} part      An instance of Part\r\n * @param  {Int}    position  Position in the master queue\r\n * @return {Void}\r\n */\r\nSequencer.prototype.addPart = function(part, position) {\r\n  if (part.length && part.pattern) {\r\n    if (!this.queue[position]) {\r\n      this.queue[position] = [];\r\n    }\r\n    this.queue[position].push(part);\r\n  } else {\r\n    throw new Error('Given parameter doesn\\'t seem to be a part object');\r\n  }\r\n};\r\n\r\n/**\r\n * Removes a part object from the master queue\r\n * @param  {Object} part     Part instance to be removed\r\n * @param  {Int}    position Position in the master queue\r\n * @return {Void}\r\n */\r\nSequencer.prototype.removePart = function(part, position) {\r\n  if (this.queue[position] instanceof Array &&\r\n    this.queue[position].length > 0) {\r\n    var index = this.queue[position].indexOf(part);\r\n    this.queue[position].splice(index, 1);\r\n  } else {\r\n    throw new Error('Part not found at position ' + position + '.');\r\n  }\r\n};\r\n\r\n/**\r\n * Set beats per minute\r\n * @param  {Int}   bpm beats per minute\r\n * @return {Void}\r\n */\r\nSequencer.prototype.setBpm = function(bpm) {\r\n  this.bpm = bpm;\r\n  this.timePerStep = this.setTimePerStep(bpm, this.resolution);\r\n};\r\n\r\n/**\r\n * Computes the time in seconds as float value\r\n * between one shortest posssible note\r\n * (64th by default) and the next.\r\n * @private\r\n * @param  {float}  bpm        beats per minute\r\n * @param  {Int}    resolution shortest possible note value\r\n * @return {float}             time in seconds\r\n */\r\nSequencer.prototype.setTimePerStep = function(bpm, resolution) {\r\n  return (60 * 4) / (bpm * resolution);\r\n};\r\n\r\nSequencer.prototype.getLastPlayedStep = function() {\r\n\r\n};\r\n\r\n/**\r\n * Makes a copy of a flat array.\r\n * Uses a pre-allocated while-loop\r\n * which seems to be the fasted way\r\n * (by far) of doing this:\r\n * http://jsperf.com/new-array-vs-splice-vs-slice/113\r\n * @private\r\n * @param  {Array} sourceArray Array that should be copied.\r\n * @return {Array}             Copy of the source array.\r\n */\r\nSequencer.prototype.copyArray = function(sourceArray) {\r\n  var destArray = new Array(sourceArray.length);\r\n  var i = sourceArray.length;\r\n  while (i--) {\r\n    destArray[i] = sourceArray[i];\r\n  }\r\n  return destArray;\r\n};\r\n\r\nmodule.exports = Sequencer;\r\n","/**\r\n * This is a webworker that provides a timer\r\n * that fires the scheduler for the sequencer.\r\n * This is because timing here is  more stable\r\n * than in the main thread.\r\n * The syntax is adapted to the commonjs module pattern.\r\n * @example <caption>It is just for library internal\r\n * usage. See Sequencer.js for details.</caption>\r\n * worker.postMessage({ 'interval': 200 });\r\n * worker.postMessage('start');\r\n * worker.postMessage('stop');\r\n * worker.terminate();  //webworker internal function, just for completeness\r\n */\r\n'use strict';\r\n\r\nvar timer = null;\r\nvar interval = 100;\r\n\r\nvar worker = function(self) {\r\n  self.addEventListener('message', function(e) {\r\n    if (e.data === 'start') {\r\n      timer = setInterval(function() {self.postMessage('tick');}, interval);\r\n    } else if (e.data === 'stop') {\r\n      clearInterval(timer);\r\n    } else if (e.data.interval) {\r\n      interval = e.data.interval;\r\n      if (timer) {\r\n        clearInterval(timer);\r\n        timer = setInterval(function() {self.postMessage('tick');}, interval);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nmodule.exports = worker;\r\n","var bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn) {\n    var keys = [];\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'], (\n            // try to call default if defined to also support babel esmodule\n            // exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);'\n        )),\n        scache\n    ];\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(sources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    return new Worker(URL.createObjectURL(\n        new Blob([src], { type: 'text/javascript' })\n    ));\n};\n"]}