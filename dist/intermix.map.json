{"version":3,"sources":["d:/Users/jansen/git/intermix.js/node_modules/karma-browserify/node_modules/browser-pack/_prelude.js","src/Part.js","src/core.js","src/scheduleWorker.js","src/Oscillator.js","src/main.js","src/Sequencer.js","src/SoundWave.js","src/Sound.js","tests/specs/coreSpec.js","node_modules/webworkify/index.js"],"names":["Part","audioCtx","instrument","length","this","resolution","multiply","name","data","pattern","monophonic","zeroPoint","Error","initPart","prototype","initPattern","i","addEvent","seqEvent","position","pos","push","removeEvent","clearPattern","getLength","getNotePositions","positions","forEach","el","index","extendOnStart","extLength","entries","extension","apply","extendOnEnd","module","exports","window","AudioContext","webkitAudioContext","timer","interval","worker","self","addEventListener","e","setInterval","postMessage","clearInterval","Oscillator","num","Intermix","require","SoundWave","Sound","Sequencer","work","beatsPerMinute","lookahead","queue","runQueue","now","timePerStep","nextStepTime","nextStep","lastPlayedStep","loop","loopStart","loopEnd","isRunning","animationFrame","setTimePerStep","scheduleWorker","onmessage","scheduler","message","currentTime","part","copyArray","seqEvents","shift","note","play","controller","splice","start","requestAnimationFrame","draw","stop","lookAheadDelta","stepsAhead","Math","floor","addPart","createNoteEvent","bpm","sourceArray","destArray","Array","core","audioSrc","buffer","ArrayBuffer","decodeAudioData","concatBinariesToAudioBuffer","indexOf","binBuffer","loadFile","response","binBuffers","loadFiles","rawAudioSrc","then","decoded","binaryBuffers","audioBuffer","tmpAudioBuffer","appendAudioBuffer","Buffer","buffer1","buffer2","numberOfChannels","min","tmp","createBuffer","sampleRate","channel","getChannelData","set","filename","onloadCallback","sync","asynchronously","request","XMLHttpRequest","open","responseType","onload","send","filenames","names","split","sortBinBuffers","map","soundBuffer","isPaused","gainNode","pannerNode","soundLength","startOffset","startTime","duration","setupAudioChain","createGain","createStereoPanner","connect","destination","gain","value","console","log","createBufferSource","bufferSource","onended","destroyBufferSource","bsNode","disconnect","node","delay","playLooped","bs","paused","pause","setLoopStart","setLoopEnd","resetLoop","setFrequency","freq","playbackRate","getFrequency","setTone","semiTone","detune","getTone","getUID","random","toString","substr","describe","beforeEach","afterEach","it","expect","toBeDefined","bundleFn","arguments","sources","cache","stringify","JSON","fn","wkey","cacheKeys","Object","keys","l","key","exp","pow","wcache","Function","skey","scache","src","join","URL","webkitURL","mozURL","msURL","Worker","createObjectURL","Blob","type"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * Part.js\r\n */\r\n'use strict';\r\n\r\nvar Part = function(audioCtx, instrument, length) {\r\n  this.audioCtx;\r\n  this.instrument;\r\n  this.resolution = 16;\r\n  this.multiply = 4;\r\n  this.length = 1;      //1 = one bar (4 beats)\r\n  this.name = 'Part';\r\n  this.data;\r\n  this.pattern = [];\r\n  this.monophonic = false; //probably futile\r\n  this.zeroPoint = 0;\r\n\r\n  if (audioCtx && instrument) {\r\n    this.audioCtx = audioCtx;\r\n    this.instrument = instrument;\r\n    this.initPart();\r\n  } else {\r\n    throw new Error('Failed to initialize part. AudioCtx and/or instrument missing.');\r\n  }\r\n\r\n  if (length) {\r\n    this.length = length;\r\n  }\r\n\r\n};\r\n\r\nPart.prototype.initPart = function() {\r\n  this.pattern = this.initPattern(this.length);\r\n  //do we really need this? And, if yes, why?\r\n  this.data = {\r\n    'name': this.name,\r\n    'instrument': this.instrument,\r\n    'resolution': this.resolution,\r\n    'pattern': this.pattern\r\n  };\r\n};\r\n\r\n/**\r\n * initPattern: Initialize an empty pattern in this part\r\n * @param  {Float}  length  Length of the pattern mesured in bars\r\n * @return {Object} The current context to make the function chainable.\r\n */\r\nPart.prototype.initPattern = function(length) {\r\n  var pattern = [];\r\n  for (var i = 0; i < (length * 64); i++) {\r\n    pattern[i] = [];\r\n  }\r\n  return pattern;\r\n};\r\n\r\n/**\r\n * addEvent: adds an event to the pattern at a given position\r\n * @param  {Object} seqEvent  The event (note or controller)\r\n * @param  {Int}    position  Position in the pattern\r\n * @return {Object} The current context to make the function chainable.\r\n */\r\nPart.prototype.addEvent = function(seqEvent, position) {\r\n  if (position <= this.resolution) {\r\n    var pos = (position - 1) * this.multiply;\r\n    this.pattern[pos].push(seqEvent);\r\n  }\r\n  return this;\r\n};\r\n\r\nPart.prototype.removeEvent = function(position) {\r\n  //removes all entries at a specific position.\r\n  //this is not exactly what it should do.\r\n  var pos = position * this.multiply;\r\n  this.pattern[pos] = [];\r\n};\r\n\r\n/**\r\n * clearPattern: Delete all events in this part\r\n * @return {Object} The current context to make the function chainable.\r\n */\r\nPart.prototype.clearPattern = function() {\r\n  this.pattern = [];\r\n  return this;\r\n};\r\n\r\nPart.prototype.getLength = function() {\r\n  return this.pattern.length;\r\n};\r\n\r\nPart.prototype.getNotePositions = function() {\r\n  var positions = [];\r\n  this.pattern.forEach(function(el, index) {\r\n    if (el.length > 0) {\r\n      positions.push(index / this.multiply);\r\n    }\r\n  }, this);\r\n  return positions;\r\n};\r\n\r\nPart.prototype.extendOnStart = function(pattern, extLength) {\r\n  var entries = extLength * 64;\r\n  var extension = this.initPattern(entries);\r\n  return pattern.push.apply(extension, pattern);\r\n};\r\n\r\nPart.prototype.extendOnEnd = function(pattern, extLength) {\r\n  var entries = extLength * 64;\r\n  var extension = this.initPattern(entries);\r\n  return pattern.push.apply(pattern, extension);\r\n};\r\n\r\nmodule.exports = Part;\r\n","/**\r\n * This simply creates the audio context objects\r\n * and exports it.\r\n *\r\n * TODO: - Should we do backwards-compatibility for older api-versions?\r\n *       - Check for mobile/iOS compatibility.\r\n *       - Check if we're running on node (and throw an error if so)\r\n */\r\n'use strict';\r\n\r\nvar audioCtx = null;\r\n\r\n(function() {\r\n\r\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\n  if (window.AudioContext) {\r\n    audioCtx = new window.AudioContext();\r\n  } else {\r\n    //TODO: throw error, probably surround with try/catch\r\n  }\r\n\r\n})();\r\n\r\nmodule.exports = {\r\n  audioCtx: audioCtx\r\n};\r\n","/**\r\n * This is a webworker that provides a timer\r\n * that fires the scheduler for the sequencer.\r\n * This is because timing here is much more stable\r\n * than in the main thread.\r\n *\r\n * The syntax is adapted to the commonjs module pattern.\r\n */\r\n'use strict';\r\n\r\nvar timer = null;\r\nvar interval = 100;\r\n\r\nvar worker = function(self) {\r\n  self.addEventListener('message', function(e) {\r\n    if (e.data === 'start') {\r\n      timer = setInterval(function() {self.postMessage('tick');}, interval);\r\n    } else if (e.data === 'stop') {\r\n      clearInterval(timer);\r\n    } else if (e.data.interval) {\r\n      interval = e.data.interval;\r\n      if (timer) {\r\n        clearInterval(timer);\r\n        timer = setInterval(function() {self.postMessage('tick');}, interval);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nmodule.exports = worker;\r\n\r\n/*eslint-disable */\r\n// self.onmessage = function(e) {\r\n//   if (e.data === 'start') {\r\n//     timer = setInterval(function() {postMessage('tick');}, interval);\r\n//   } else if (e.data === 'stop') {\r\n//     clearInterval(timer);\r\n//   } else if (e.data.interval) {\r\n//     interval = e.data.interval;\r\n//     if (timer) {\r\n//       clearInterval(timer);\r\n//       timer = setInterval(function() {postMessage('tick');}, interval);\r\n//     }\r\n//   }\r\n//\r\n//   self.close();\r\n// };\r\n","/**\r\n *\r\n */\r\n'use strict';\r\nvar Oscillator = function(num) {\r\n  return num;\r\n};\r\n\r\nmodule.exports = Oscillator;\r\n","'use strict';\r\n\r\n//Intermix = require('./core.js');\r\nvar Intermix = require('./core.js') || {};\r\nIntermix.SoundWave = require('./SoundWave.js');\r\nIntermix.Sound = require('./Sound.js');\r\nIntermix.Sequencer = require('./Sequencer.js');\r\nIntermix.Part = require('./Part.js');\r\n\r\nmodule.exports = Intermix;\r\n","/**\r\n * Sequencer\r\n *\r\n * Scheduling inspired by \"A Tale of Two Clocks\" by Chris Wilson:\r\n * http://www.html5rocks.com/en/tutorials/audio/scheduling/\r\n */\r\n'use strict';\r\n\r\nvar work = require('webworkify');\r\n\r\nvar Sequencer = function(audioCtx) {\r\n\r\n  var self = this;\r\n  this.audioCtx = audioCtx;\r\n  this.beatsPerMinute = 120;  //beats per minute\r\n  this.resolution = 64;       //shortest possible note. You normally don't want to touch this.\r\n  this.interval = 100;        //the interval in miliseconds the scheduler gets invoked.\r\n  this.lookahead = 0.3;       //time in seconds the scheduler looks ahead.\r\n                              //should be longer than interval.\r\n  this.queue = [];            //List with all parts of the score\r\n  this.runQueue = [];         //list with parts that are playing or will be played shortly\r\n\r\n  this.now;                    //timestamp from audiocontext when the scheduler is invoked.\r\n  this.timePerStep;           //period of time between two steps\r\n  this.nextStepTime = 0;      //time in seconds when the next step will be triggered\r\n  this.nextStep = 0;          //position in the queue that will get triggered next\r\n  this.lastPlayedStep = 0;    //step in queue that was played (not triggered) recently (used for drawing).\r\n  this.loop = false;          //play a section of the queue in a loop\r\n  this.loopStart;             //first step of the loop\r\n  this.loopEnd;               //last step of the loop\r\n  this.isRunning = false;     //true if sequencer is running, otherwise false\r\n  this.animationFrame;        //has to be overridden with a function. Will be called in the\r\n                              //draw function with the lastPlayedStep int as parameter.\r\n\r\n  // set time per setTimePerStep\r\n  this.timePerStep = this.setTimePerStep(this.beatsPerMinute, this.resolution);\r\n\r\n  // Initialize the scheduler-timer\r\n  this.scheduleWorker = work(require('./scheduleWorker.js'));\r\n\r\n  /*eslint-enable */\r\n\r\n  this.scheduleWorker.onmessage = function(e) {\r\n    if (e.data === 'tick') {\r\n      self.scheduler();\r\n    }\r\n  };\r\n\r\n  this.scheduleWorker.postMessage({'message': this.interval});\r\n};\r\n\r\nSequencer.prototype.scheduler = function() {\r\n  this.now = this.audioCtx.currentTime;\r\n\r\n  if (this.nextStepTime === 0) {\r\n    this.nextStepTime = this.now;\r\n  }\r\n\r\n  while (this.nextStepTime < this.now + this.lookahead) {\r\n    if (this.queue[this.nextStep]) {\r\n      this.queue[this.nextStep].forEach(function(part) {\r\n        this.runQueue.push({\r\n          'instrument': part.instrument,\r\n          'pattern': this.copyArray(part.pattern)\r\n        });\r\n      }, this);\r\n    }\r\n\r\n    this.runQueue.forEach(function(part, index) {\r\n      var seqEvents = part.pattern.shift();  //return first element and remove it from part\r\n      if (seqEvents) {\r\n        //var instrument = part.instrument;\r\n        seqEvents.forEach(function(seqEvent) {\r\n          if (seqEvent.note) {\r\n            //TODO: should be extended to play real notes\r\n            part.instrument.play(this.nextStepTime);\r\n          } else if (seqEvent.controller) {\r\n            // process controller event;\r\n          }\r\n\r\n          //remove part from runQueue if empty\r\n          if (part.pattern.length === 0) {\r\n            this.runQueue.splice(index, 1);\r\n          }\r\n        }, this);\r\n      }\r\n\r\n    }, this);\r\n\r\n    this.nextStepTime += this.timePerStep;\r\n\r\n    // set pointer to the next step in the queue that should be played.\r\n    // If we're playing in loop mode, jump back to loopstart when\r\n    // end of loop is reached.\r\n    if (this.loop) {\r\n      if (this.nextStep >= this.loopEnd) {\r\n        this.nextStep = this.loopStart;\r\n        this.runQueue = [];\r\n      } else {\r\n        this.nextStep++;\r\n      }\r\n    } else {\r\n      this.nextStep++;\r\n    }\r\n  }\r\n};\r\n\r\nSequencer.prototype.start = function() {\r\n  this.scheduleWorker.postMessage('start');\r\n  this.isRunning = true;\r\n  window.requestAnimationFrame(this.draw);\r\n};\r\n\r\nSequencer.prototype.stop = function() {\r\n  this.scheduleWorker.postMessage('stop');\r\n  this.runQueue = [];\r\n  this.isRunning = false;\r\n};\r\n\r\nSequencer.prototype.draw = function() {\r\n  // first we'll have to find out, what step was recently played.\r\n  // this is somehow clumsy because the sequencer doesn't keep track of that.\r\n  var lookAheadDelta = this.nextStepTime - this.audioCtx.currentTime;\r\n  var stepsAhead = Math.floor(lookAheadDelta / this.timePerStep) + 1;\r\n  this.lastPlayedStep = this.nextStep - stepsAhead;\r\n\r\n  //should be overridden by the application\r\n  this.animationFrame(this.lastPlayedStep);\r\n\r\n  if (this.isRunning) {\r\n    window.requestAnimationFrame(this.draw);\r\n  }\r\n};\r\n\r\nSequencer.prototype.addPart = function(part, position) {\r\n  if (!this.queue[position]) {\r\n    this.queue[position] = [];\r\n  }\r\n  this.queue[position].push(part);\r\n};\r\n\r\nSequencer.prototype.createNoteEvent = function(note, length) {\r\n  return {\r\n    'note': note,\r\n    'length': length\r\n  };\r\n};\r\n\r\nSequencer.prototype.setTimePerStep = function(bpm, resolution) {\r\n  return (60 * 4) / (bpm * resolution);\r\n};\r\n\r\n/**\r\n * copyArray: Makes a copy of a flat array.\r\n * \t\t\t\t\t\tUses a pre-allocated while-loop\r\n * \t\t\t\t\t\twhich seems to be the fasted way\r\n * \t\t\t\t\t\t(by far) of doing this:\r\n * \t\t\t\t\t\thttp://jsperf.com/new-array-vs-splice-vs-slice/113\r\n * @param  {Array} sourceArray Array that should be copied.\r\n * @return {Array}             Copy of the source array.\r\n */\r\nSequencer.prototype.copyArray = function(sourceArray) {\r\n  var destArray = new Array(sourceArray.length);\r\n  var i = sourceArray.length;\r\n  while (i--) {\r\n    destArray[i] = sourceArray[i];\r\n  }\r\n  return destArray;\r\n};\r\n\r\nmodule.exports = Sequencer;\r\n","'use strict';\r\n\r\nvar core = require('./core.js');\r\n\r\n/**\r\n * Creates a wrapper in which an audio buffer lives.\r\n * It can handle one or more ArrayBuffers or filenames\r\n * (*.wav, *.mp3) as data sources.\r\n * Multiple sources will be concatenated into one audio buffer.<br>\r\n * You normally shouldn't use any of the provided methods.\r\n * A SoundWave object just holds audio data and does nothing.\r\n * If you want to play the sound, you have to additionally create a Sound object.\r\n * @example <caption>Play a sound from an audio file:</caption>\r\n * var soundWave = new Intermix.SoundWave('file.wav');\r\n * var sound = new Intermix.Sound(soundWave.buffer);\r\n * sound.play;\r\n * @example <caption>Concatenate multiple source files into one buffer<br>\r\n * in the given order and play them:</caption>\r\n * var soundWave = new Intermix.SoundWave('file1.wav,file2.wav,file3.wav');\r\n * var sound = new Intermix.Sound(soundWave.buffer);\r\n * sound.play;\r\n * @example <caption>\r\n * Using ArrayBuffers instead of filenames will come in handy if you want<br>\r\n * to have full control over XHR or use a preloader (here: preload.js):\r\n * </caption>\r\n * var queue = new createjs.LoadQueue();\r\n * queue.on('complete', handleComplete);\r\n * queue.loadManifest([\r\n *     {id: 'src1', src:'file1.wav', type:createjs.AbstractLoader.BINARY},\r\n *     {id: 'src2', src:'file2.wav', type:createjs.AbstractLoader.BINARY}\r\n * ]);\r\n *\r\n * function handleComplete() {\r\n *     var binData1 = queue.getResult('src1');\r\n *     var binData2 = queue.getResult('src2');\r\n *     var wave1 = new Intermix.SoundWave(binData1);\r\n *     var wave2 = new Intermix.SoundWave(binData2);\r\n *     var concatWave = new Intermix.SoundWave([binData1, binData2]);\r\n * };\r\n * @constructor\r\n * @param  {(Object|Object[]|string)} audioSrc   One or more ArrayBuffers or filenames\r\n */\r\nvar SoundWave = function(audioSrc) {\r\n\r\n  this.audioCtx = core.audioCtx;  //window.AudioContext\r\n  this.buffer = null;             //AudioBuffer\r\n//s\r\n  if (audioSrc) {\r\n    if (audioSrc instanceof ArrayBuffer) {\r\n      //one audio buffer to decode\r\n      this.decodeAudioData(audioSrc);\r\n    } else if (audioSrc instanceof Array && audioSrc[0] instanceof ArrayBuffer) {\r\n      //multiple audio buffers to decode and concatenate\r\n      this.concatBinariesToAudioBuffer(audioSrc);\r\n    } else if (typeof audioSrc === 'string' && audioSrc.indexOf(',') === 0) {\r\n      //one file to load/decode\r\n      var binBuffer;\r\n      this.loadFile(audioSrc, function(response) {\r\n        binBuffer = response;\r\n      });\r\n      this.buffer = this.decodeAudioData(binBuffer);\r\n    } else if (typeof audioSrc === 'string' && audioSrc.indexOf(',') > -1) {\r\n      //multiple files to load/decode and cancatinate\r\n      var binBuffers = this.loadFiles(audioSrc);\r\n      this.concatBinariesToAudioBuffer(binBuffers);\r\n    }\r\n  } else {\r\n    throw new Error('Cannot create SoundWave object: Binary data missing.');\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * Takes binary audio data and turns it into an audio buffer object.\r\n * This is a wrapper for the web-audio-api decodeAudioData function.\r\n * @param  {ArrayBuffer} rawAudioSrc Audio data in raw binary format\r\n * @return {AudioBuffer}             Ready to use audio buffer\r\n */\r\nSoundWave.prototype.decodeAudioData = function(rawAudioSrc) {\r\n  return this.audioCtx.decodeAudioData(rawAudioSrc).then(function(decoded) {\r\n    return decoded;\r\n  });\r\n};\r\n\r\n/**\r\n * Concatenates one or more ArrayBuffers to an AudioBuffer.\r\n * @param  {Array} binaryBuffers  Array holding one or more ArrayBuffers\r\n * @param  {AudioBuffer} audioBuffer   An existing AudioBuffer object\r\n * @return {AudioBuffer}               The concatenated AudioBuffer\r\n */\r\nSoundWave.prototype.concatBinariesToAudioBuffer = function(binaryBuffers, audioBuffer) {\r\n  var self = this;\r\n\r\n  binaryBuffers.forEach(function(binBuffer) {\r\n    var tmpAudioBuffer = self.decodeAudioData(binBuffer);\r\n    audioBuffer = self.appendAudioBuffer(self.Buffer, tmpAudioBuffer);\r\n  });\r\n\r\n  return audioBuffer;\r\n};\r\n\r\n/**\r\n * Appends two audio buffers. Suggested by Chris Wilson:<br>\r\n * http://stackoverflow.com/questions/14143652/web-audio-api-append-concatenate-different-audiobuffers-and-play-them-as-one-son\r\n * @param  {AudioBuffer} buffer1 The first audio buffer\r\n * @param  {AudioBuffer} buffer2 The second audio buffer\r\n * @return {AudioBuffer}         buffer1 + buffer2\r\n */\r\nSoundWave.prototype.appendAudioBuffer = function(buffer1, buffer2) {\r\n  var numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);\r\n  var tmp = this.audioCtx.createBuffer(numberOfChannels,\r\n    (buffer1.length + buffer2.length),\r\n    buffer1.sampleRate);\r\n  for (var i = 0; i < numberOfChannels; i++) {\r\n    var channel = tmp.getChannelData(i);\r\n    channel.set( buffer1.getChannelData(i), 0);\r\n    channel.set( buffer2.getChannelData(i), buffer1.length);\r\n  }\r\n  return tmp;\r\n};\r\n\r\n/**\r\n * Loads a binary file and calls a function with the\r\n * returned ArrayBuffer as its argument when done.\r\n * @param  {string}   filename       The file to be loaded\r\n * @param  {function} onloadCallback The function to be called\r\n * @param  {boolean}  [sync=true]   Asynchronous loading\r\n * @example\r\n * var arrayBuffer;\r\n * this.loadFile('file1.wav', function(response) {\r\n *   arrayBuffer = response;\r\n * });\r\n */\r\nSoundWave.prototype.loadFile = function(filename, onloadCallback, sync) {\r\n  var asynchronously = true;\r\n  var request = new window.XMLHttpRequest();\r\n\r\n  if (sync) {\r\n    asynchronously = sync;\r\n  }\r\n\r\n  request.open('GET', filename, asynchronously);\r\n  request.responseType = 'arraybuffer';\r\n\r\n  request.onload = function() {\r\n    onloadCallback(request.response);\r\n  };\r\n\r\n  request.send();\r\n};\r\n\r\n/**\r\n * Loads multiple binary files and returns an array\r\n * with the data from the files in the given order.\r\n * @param  {Array}  filenames List with filenames\r\n * @return {Array}            Array of ArrayBuffers\r\n */\r\nSoundWave.prototype.loadFiles = function(filenames) {\r\n  var self = this;\r\n  var binBuffers = [];\r\n  var names = filenames.split(',');\r\n  names.forEach(function(name) {\r\n    self.loadFile(name, function(response) {\r\n      binBuffers[name] = response;\r\n    });\r\n  });\r\n\r\n  return this.sortBinBuffers(names, binBuffers);\r\n};\r\n\r\nSoundWave.prototype.sortBinBuffers = function(filenames, binBuffers) {\r\n  return filenames.map(function(el) {\r\n    binBuffers[el];\r\n  });\r\n};\r\n\r\nmodule.exports = SoundWave;\r\n","'use strict';\r\n\r\nvar Sound = function(audioCtx, soundBuffer) {\r\n\r\n  this.audioCtx = null;\r\n  this.buffer = null;\r\n  this.queue = [];          //all currently active streams\r\n  this.loop = false;\r\n  this.isPaused = false;\r\n  this.gainNode = null;\r\n  this.pannerNode = null;\r\n\r\n  this.soundLength = 0;\r\n  this.startOffset = 0;\r\n  this.startTime = 0;\r\n  this.loopStart = 0;\r\n  this.loopEnd = null;\r\n\r\n  if (soundBuffer && audioCtx) {\r\n    this.audioCtx = audioCtx;\r\n    this.buffer = soundBuffer;\r\n    this.soundLength = this.loopEnd = soundBuffer.duration;\r\n    this.setupAudioChain();\r\n  } else {\r\n    throw new Error('Error initialising Sound object: parameter missing.');\r\n  }\r\n};\r\n\r\nSound.prototype.setupAudioChain = function() {\r\n  this.gainNode = this.audioCtx.createGain();\r\n  this.pannerNode = this.audioCtx.createStereoPanner();\r\n  this.gainNode.connect(this.pannerNode);\r\n  this.pannerNode.connect(this.audioCtx.destination);\r\n  this.gainNode.gain.value = 1;\r\n  console.log('audiochain ready');\r\n};\r\n\r\nSound.prototype.createBufferSource = function() {\r\n  var self = this;\r\n  var bufferSource = this.audioCtx.createBufferSource();\r\n  bufferSource.buffer = this.buffer;\r\n  bufferSource.connect(this.gainNode);\r\n  bufferSource.onended = function() {\r\n    console.log('onended fired');\r\n    self.destroyBufferSource(bufferSource);\r\n  };\r\n  return bufferSource;\r\n};\r\n\r\nSound.prototype.destroyBufferSource = function(bsNode) {\r\n  var self = this;\r\n  bsNode.disconnect();\r\n  this.queue.forEach(function(node, index) {\r\n    if (node === bsNode) {\r\n      self.queue.splice(index, 1);\r\n    }\r\n  });\r\n  bsNode = null; //probably futile\r\n  console.log('BufferSourceNode destroyed');\r\n};\r\n\r\nSound.prototype.play = function(delay, playLooped) {\r\n  var startTime = 0;\r\n\r\n  if (delay) {\r\n    console.log('set start time: ' + delay);\r\n    startTime = delay;\r\n  } else {\r\n    startTime = this.audioCtx.currentTime;\r\n  }\r\n  var bs = this.createBufferSource();\r\n  bs.loop = playLooped;\r\n\r\n  // if (playLooped) {\r\n  //   bs.loopStart = this.loopStart;\r\n  //   bs.loopEnd = this.loopEnd;\r\n  // }\r\n\r\n  // if (this.startOffset === 0 || this.startOffset >= this.buffer.duration) {\r\n  //   console.log('resetting starttime');\r\n  //   this.startTime = this.audioCtx.currentTime;\r\n  // }\r\n  this.queue.push(bs);\r\n  //bs.start(startTime, this.startOffset);\r\n  bs.start(startTime);\r\n\r\n  this.startOffset = 0;\r\n};\r\n\r\nSound.prototype.stop = function(paused) {\r\n  if (paused) { //this has to be rewritten since there could be multiple start times.\r\n    this.startOffset = this.audioCtx.currentTime - this.startTime;\r\n    this.paused = false;\r\n  }\r\n  if (this.queue.length > 0) {\r\n    this.queue.forEach(function(node) {\r\n      node.stop();\r\n    });\r\n  } else {\r\n    //fail silently\r\n  }\r\n};\r\n\r\nSound.prototype.pause = function() {\r\n  this.isPaused = true;\r\n  this.stop(this.isPaused);\r\n};\r\n\r\nSound.prototype.setLoopStart = function(value) {\r\n  this.loopStart = value * this.soundLength;\r\n  this.bufferSource.loopStart = this.loopStart;\r\n};\r\n\r\nSound.prototype.setLoopEnd = function(value) {\r\n  this.loopEnd = value * this.soundLength;\r\n  this.bufferSource.loopEnd = this.loopEnd;\r\n};\r\n\r\nSound.prototype.resetLoop = function() {\r\n  this.loopStart = 0;\r\n  this.loopEnd = this.soundLength;\r\n};\r\n\r\nSound.prototype.setFrequency = function(freq) {\r\n  this.bufferSource.playbackRate.value = freq;\r\n};\r\n\r\nSound.prototype.getFrequency = function() {\r\n  return this.bufferSource.playbackRate.value;\r\n};\r\n\r\nSound.prototype.setTone = function(semiTone) {\r\n  this.bufferSource.detune.value = semiTone * 100;\r\n};\r\n\r\nSound.prototype.getTone = function() {\r\n  return this.bufferSource.detune.value;\r\n};\r\n\r\nSound.prototype.getUID = function() {\r\n  return Math.random().toString().substr(2, 8);\r\n};\r\n\r\nmodule.exports = Sound;\r\n","'use strict';\r\n\r\nvar Intermix = require('../../src/core.js');\r\ndescribe('The intermix core', function() {\r\n\r\n  beforeEach(function() {\r\n    //intermix = new Intermix();\r\n    //var zwo = 2;\r\n  });\r\n\r\n  afterEach(function() {\r\n    //intermix = null;\r\n  });\r\n\r\n  it('should initialize the audio context object', function() {\r\n    expect(Intermix.audioCtx).toBeDefined();\r\n  });\r\n});\r\n","var bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn) {\n    var keys = [];\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'], (\n            // try to call default if defined to also support babel esmodule\n            // exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);'\n        )),\n        scache\n    ];\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(sources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    return new Worker(URL.createObjectURL(\n        new Blob([src], { type: 'text/javascript' })\n    ));\n};\n"]}