(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{76:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return s}));var a=t(2),i=t(6),o=(t(0),t(89)),r={id:"Intermix v0.8.0 Released",title:"Intermix v0.8.0 Released",author:"Roland Jansen",tags:["release","intermix","audio-routing","config","sourcemaps","documentation"]},c={permalink:"/intermix/blog/Intermix v0.8.0 Released",editUrl:"https://github.com/RolandJansen/intermix/tree/homepage/blog/blog/2020-10-06-Version-0.8-released.md",source:"@site/blog\\2020-10-06-Version-0.8-released.md",description:"Intermix Version 0.8.0 introduces advanced audio routing and comes with a basic delay fx plugin.",date:"2020-10-06T00:00:00.000Z",tags:[{label:"release",permalink:"/intermix/blog/tags/release"},{label:"intermix",permalink:"/intermix/blog/tags/intermix"},{label:"audio-routing",permalink:"/intermix/blog/tags/audio-routing"},{label:"config",permalink:"/intermix/blog/tags/config"},{label:"sourcemaps",permalink:"/intermix/blog/tags/sourcemaps"},{label:"documentation",permalink:"/intermix/blog/tags/documentation"}],title:"Intermix v0.8.0 Released",readingTime:2.145,truncated:!0,nextItem:{title:"Intermix v0.7.0 Released",permalink:"/intermix/blog/Intermix v0.7.0 Released"}},l=[{value:"Audio Routing",id:"audio-routing",children:[]},{value:"Config / Sourcemaps",id:"config--sourcemaps",children:[]},{value:"Documentation",id:"documentation",children:[]}],u={rightToc:l};function s(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Intermix Version 0.8.0 introduces advanced audio routing and comes with a basic delay fx plugin."),Object(o.b)("p",null,"Now plugins can be connected by a simple function call. Routing is done in realtime while intermix keeps track of the state of the audio graph."),Object(o.b)("h3",{id:"audio-routing"},"Audio Routing"),Object(o.b)("p",null,"In the following example, ",Object(o.b)("inlineCode",{parentName:"p"},"synthOut")," and ",Object(o.b)("inlineCode",{parentName:"p"},"delayIn")," are audio endpoints. These are tuples that contain the plugin id and the channel number. The new ",Object(o.b)("inlineCode",{parentName:"p"},"connectPlugins")," function takes two audio endpoints as arguments - an output followed by an input:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"import { addPlugin, connectPlugins } from \"intermix\";\n\nconst synthID = addPlugin('Synth');\nconst delayID = addPlugin('Delay');\n\n// now we connect the 1st output of the synth\n// to the 1st input of the delay\nconst synthOut = [synthID, 0];\nconst delayIn = [delayID, 0];\nconnectPlugins(synthOut, delayIn);\n")),Object(o.b)("p",null,"The delay plugin doesn't need output wiring because all plugins are connected to the soundcard by default. If you want to disconnect these plugins simply route the synth to the soundcard again:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'connectPlugins(synthOut, ["destination", 0]);\n')),Object(o.b)("p",null,"The soundcard is called ",Object(o.b)("em",{parentName:"p"},"destination")," according to the audio context and has just one input. Intermix will automatically disconnect the synth from the delay and log the new state. If you want to connect a plugin to multiple inputs you have to use multiple outputs(*)."),Object(o.b)("h3",{id:"config--sourcemaps"},"Config / Sourcemaps"),Object(o.b)("p",null,"I stripped the sourcemaps from the production build to get an even smaller package size (<80k). Instead, there are non-minified bundles to be used in a node environment. A minified ES2015 bundle is still included and can be embedded directly into a website via script tag. Minified CommonJS is also removed because it can't be used in the browser."),Object(o.b)("p",null,"The point is that sourcemaps are pretty useless in an npm package where you don't have direct access to the unbundled sourcecode. Instead, seeing readable, uncompressed production-code in the debugger makes absolutely sense. And if you're developing in a node environment, chances are that you minify the output anyway."),Object(o.b)("h3",{id:"documentation"},"Documentation"),Object(o.b)("p",null,"Another thing worth mentioning is that ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/API_functions"}),"API functions")," are now documented on this webpage. There are still things missing like Typescript stuff (public interfaces and types) but I'll keep more attention to this from now on."),Object(o.b)("p",null,"You can read about all changes in detail in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/CHANGELOG"}),"Changelog"),"."),Object(o.b)("p",null,"(*): The Web Audio API allows multiple connections from/to single audio nodes and it's ok to use this ",Object(o.b)("em",{parentName:"p"},"within")," plugins. However, connections ",Object(o.b)("em",{parentName:"p"},"between")," plugins are always one-to-one. This doesn't apply to the ",Object(o.b)("em",{parentName:"p"},"destination")," because it's not a plugin but the representation of a hardware device. It can have multiple audio endpoints wired to its input."))}s.isMDXComponent=!0},89:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return b}));var a=t(0),i=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var u=i.a.createContext({}),s=function(e){var n=i.a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=s(e.components);return i.a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(t),m=a,b=d["".concat(r,".").concat(m)]||d[m]||p[m]||o;return t?i.a.createElement(b,c(c({ref:n},u),{},{components:t})):i.a.createElement(b,c({ref:n},u))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,r[1]=c;for(var u=2;u<o;u++)r[u]=t[u];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);